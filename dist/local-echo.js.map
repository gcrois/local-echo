{
  "version": 3,
  "sources": ["../node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/quote.js", "../node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/parse.js", "../node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/index.js", "../lib/HistoryController.ts", "../lib/utils.ts", "../lib/LocalEchoController.ts", "../index.ts"],
  "sourcesContent": ["'use strict';\n\nmodule.exports = function quote(xs) {\n\treturn xs.map(function (s) {\n\t\tif (s && typeof s === 'object') {\n\t\t\treturn s.op.replace(/(.)/g, '\\\\$1');\n\t\t}\n\t\tif ((/[\"\\s]/).test(s) && !(/'/).test(s)) {\n\t\t\treturn \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n\t\t}\n\t\tif ((/[\"'\\s]/).test(s)) {\n\t\t\treturn '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n\t\t}\n\t\treturn String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@[\\\\\\]^`{|}])/g, '$1\\\\$2');\n\t}).join(' ');\n};\n", "'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|',\n\t'\\\\&\\\\&',\n\t';;',\n\t'\\\\|\\\\&',\n\t'\\\\<\\\\(',\n\t'\\\\<\\\\<\\\\<',\n\t'>>',\n\t'>\\\\&',\n\t'<\\\\&',\n\t'[&;()|<>]'\n].join('|') + ')';\nvar controlRE = new RegExp('^' + CONTROL + '$');\nvar META = '|&;()<> \\\\t';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar hash = /^#$/;\n\nvar SQ = \"'\";\nvar DQ = '\"';\nvar DS = '$';\n\nvar TOKEN = '';\nvar mult = 0x100000000; // Math.pow(16, 8);\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (mult * Math.random()).toString(16);\n}\nvar startsWithToken = new RegExp('^' + TOKEN);\n\nfunction matchAll(s, r) {\n\tvar origIndex = r.lastIndex;\n\n\tvar matches = [];\n\tvar matchObj;\n\n\twhile ((matchObj = r.exec(s))) {\n\t\tmatches.push(matchObj);\n\t\tif (r.lastIndex === matchObj.index) {\n\t\t\tr.lastIndex += 1;\n\t\t}\n\t}\n\n\tr.lastIndex = origIndex;\n\n\treturn matches;\n}\n\nfunction getVar(env, pre, key) {\n\tvar r = typeof env === 'function' ? env(key) : env[key];\n\tif (typeof r === 'undefined' && key != '') {\n\t\tr = '';\n\t} else if (typeof r === 'undefined') {\n\t\tr = '$';\n\t}\n\n\tif (typeof r === 'object') {\n\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t}\n\treturn pre + r;\n}\n\nfunction parseInternal(string, env, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tvar BS = opts.escape || '\\\\';\n\tvar BAREWORD = '(\\\\' + BS + '[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'\n\t].join('|'), 'g');\n\n\tvar matches = matchAll(string, chunker);\n\n\tif (matches.length === 0) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\n\tvar commented = false;\n\n\treturn matches.map(function (match) {\n\t\tvar s = match[0];\n\t\tif (!s || commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (controlRE.test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\tvar char = s.charAt(i);\n\n\t\t\tif (char === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i - 2, i + 1));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.slice(i, varend);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(char)) {\n\t\t\t\tvarname = char;\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar slicedFromI = s.slice(i);\n\t\t\t\tvarend = slicedFromI.match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = slicedFromI;\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = slicedFromI.slice(0, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(env, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (controlRE.test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if (hash.test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tvar commentObj = { comment: string.slice(match.index + i + 1) };\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, commentObj];\n\t\t\t\t}\n\t\t\t\treturn [commentObj];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed arguments\n\t\t// TODO: replace this whole reduce with a concat\n\t\treturn typeof arg === 'undefined' ? prev : prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (startsWithToken.test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n", "'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n", "/**\n * The history controller provides a ring-buffer\n */\nexport class HistoryController {\n  private size: number;\n  private entries: string[];\n  private cursor: number;\n\n  constructor(size: number) {\n    this.size = size;\n    this.entries = [];\n    this.cursor = 0;\n  }\n\n  /**\n   * Push an entry and maintain ring buffer size\n   */\n  push(entry: string): void {\n    // Skip empty entries\n    if (entry.trim() === \"\") return;\n\n    // Skip duplicate entries\n    const lastEntry = this.entries[this.entries.length - 1];\n    if (entry === lastEntry) return;\n\n    // Keep track of entries\n    this.entries.push(entry);\n    if (this.entries.length > this.size) {\n      this.entries.shift();\n    }\n    this.cursor = this.entries.length;\n  }\n\n  /**\n   * Rewind history cursor to the last entry\n   */\n  rewind(): void {\n    this.cursor = this.entries.length;\n  }\n\n  /**\n   * Returns the previous entry\n   */\n  getPrevious(): string | undefined {\n    const idx = Math.max(0, this.cursor - 1);\n    this.cursor = idx;\n    return this.entries[idx];\n  }\n\n  /**\n   * Returns the next entry\n   */\n  getNext(): string | undefined {\n    const idx = Math.min(this.entries.length, this.cursor + 1);\n    this.cursor = idx;\n    return this.entries[idx];\n  }\n}", "import { parse, ParseEntry } from \"shell-quote\";\n\n/**\n * Detects all the word boundaries in the given input.\n */\nexport function wordBoundaries(input: string, leftSide: boolean = true): number[] {\n  let match: RegExpExecArray | null;\n  const words: number[] = [];\n  const rx: RegExp = /\\w+/g;\n\n  while ((match = rx.exec(input))) {\n    words.push(leftSide ? match.index : match.index + match[0].length);\n  }\n\n  return words;\n}\n\n/**\n * Finds the closest left word boundary of the given input at the given offset.\n */\nexport function closestLeftBoundary(input: string, offset: number): number {\n  const found = wordBoundaries(input, true)\n    .reverse()\n    .find(x => x < offset);\n  return found ?? 0;\n}\n\n/**\n * Finds the closest right word boundary of the given input at the given offset.\n */\nexport function closestRightBoundary(input: string, offset: number): number {\n  const found = wordBoundaries(input, false).find(x => x > offset);\n  return found ?? input.length;\n}\n\n/**\n * Converts an offset in the given input to a column/row location.\n */\nexport function offsetToColRow(input: string, offset: number, maxCols: number): { row: number, col: number } {\n  let row = 0, col = 0;\n\n  for (let i = 0; i < offset; ++i) {\n    const chr = input.charAt(i);\n    if (chr === \"\\n\") {\n      col = 0;\n      row += 1;\n    } else {\n      col += 1;\n      if (col > maxCols) {\n        col = 0;\n        row += 1;\n      }\n    }\n  }\n\n  return { row, col };\n}\n\n/**\n * Counts the lines in the given input.\n */\nexport function countLines(input: string, maxCols: number): number {\n  return offsetToColRow(input, input.length, maxCols).row + 1;\n}\n\n/**\n * Checks if there is an incomplete input.\n */\nexport function isIncompleteInput(input: string): boolean {\n  if (input.trim() === \"\") {\n    return false;\n  }\n\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\n    return true;\n  }\n\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\n    return true;\n  }\n\n  if (input.split(/(\\|\\||\\||&&)/g).pop()?.trim() === \"\") {\n    return true;\n  }\n\n  return input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\");\n}\n\n/**\n * Checks if the input ends with trailing whitespace.\n */\nexport function hasTailingWhitespace(input: string): boolean {\n  return /[^\\\\][ \\t]$/m.test(input);\n}\n\n/**\n * Returns the last token in the given input.\n */\nexport function getLastToken(input: string): string {\n  if (input.trim() === \"\" || hasTailingWhitespace(input)) {\n    return \"\";\n  }\n\n  const tokens = parse(input) as string[];\n  return tokens.pop() || \"\";\n}\n\n/**\n * Collects autocomplete candidates based on the input and callback functions.\n */\nexport function collectAutocompleteCandidates(\n  callbacks: { fn: (index: number, tokens: string[], ...args: unknown[]) => string[], args: unknown[] }[],\n  input: string\n): string[] {\n  const tokens = parse(input) as string[];\n  let index = tokens.length - 1;\n  let expr = tokens[index] || \"\";\n\n  if (input.trim() === \"\") {\n    index = 0;\n    expr = \"\";\n  } else if (hasTailingWhitespace(input)) {\n    index += 1;\n    expr = \"\";\n  }\n\n  return callbacks.reduce<string[]>((candidates, { fn, args }) => {\n    try {\n      return candidates.concat(fn(index, tokens, ...args));\n    } catch (e) {\n      console.error(\"Auto-complete error:\", e);\n      return candidates;\n    }\n  }, []).filter(txt => txt.startsWith(expr));\n}\n\n/**\n * Returns the longest common starting substring in a list of strings.\n */\nexport function getSharedFragment(fragment: string, candidates: string[]): string | null {\n  if (fragment.length >= candidates[0].length) return fragment;\n\n  const oldFragment = fragment;\n  fragment += candidates[0].slice(fragment.length, fragment.length + 1);\n\n  for (let i = 0; i < candidates.length; i++) {\n    if (!candidates[i].startsWith(oldFragment)) return null;\n    if (!candidates[i].startsWith(fragment)) {\n      return oldFragment;\n    }\n  }\n\n  return getSharedFragment(fragment, candidates);\n}\n", "import { HistoryController } from \"./HistoryController\";\nimport {\n  closestLeftBoundary,\n  closestRightBoundary,\n  collectAutocompleteCandidates,\n  countLines,\n  getLastToken,\n  hasTailingWhitespace,\n  isIncompleteInput,\n  offsetToColRow,\n  getSharedFragment\n} from \"./utils\";\nimport { Terminal } from \"xterm\";\n\ninterface LocalEchoControllerOptions {\n  historySize?: number;\n  maxAutocompleteEntries?: number;\n}\n\ninterface TermSize {\n  cols: number;\n  rows: number;\n}\n\ninterface ActivePrompt {\n  prompt: string;\n  continuationPrompt: string;\n  resolve: (value: string) => void;\n  reject: (reason?: any) => void;\n}\n\ninterface ActiveCharPrompt {\n  prompt: string;\n  resolve: (value: string) => void;\n  reject: (reason?: any) => void;\n}\n\ninterface AutocompleteHandler {\n  fn: Function;\n  args: any[];\n}\n\n/**\n * A local terminal controller is responsible for displaying messages\n * and handling local echo for the terminal.\n *\n * Local echo supports most of bash-like input primitives. Namely:\n * - Arrow navigation on the input\n * - Alt-arrow for word-boundary navigation\n * - Alt-backspace for word-boundary deletion\n * - Multi-line input for incomplete commands\n * - Auto-complete hooks\n */\nexport default class LocalEchoController {\n  private term: Terminal | null;\n  private history: HistoryController;\n  private maxAutocompleteEntries: number;\n  private _autocompleteHandlers: AutocompleteHandler[];\n  private _active: boolean;\n  private _input: string;\n  private _cursor: number;\n  private _activePrompt: ActivePrompt | null;\n  private _activeCharPrompt: ActiveCharPrompt | null;\n  private _termSize: TermSize;\n  private _disposables: { dispose: () => void }[];\n  private _handleTermData: (data: string) => void;\nprivate _handleTermResize: (data: { rows: number; cols: number }) => void;\n\n  constructor(term: Terminal | null = null, options: LocalEchoControllerOptions = {}) {\n    this.term = term;\n    this._handleTermData = this.handleTermData.bind(this);\n    this._handleTermResize = this.handleTermResize.bind(this);\n    \n    this.history = new HistoryController(options.historySize || 10);\n    this.maxAutocompleteEntries = options.maxAutocompleteEntries || 100;\n\n    this._autocompleteHandlers = [];\n    this._active = false;\n    this._input = \"\";\n    this._cursor = 0;\n    this._activePrompt = null;\n    this._activeCharPrompt = null;\n    this._termSize = {\n      cols: 0,\n      rows: 0,\n    };\n\n    this._disposables = [];\n    \n    if (term) {\n      if ('loadAddon' in term) term.loadAddon(this);\n      else this.attach();\n    }\n  }\n\n  // xterm.js new plugin API:\n  activate(term: Terminal): void {\n    this.term = term;\n    this.attach();\n  }\n\n  dispose(): void {\n    this.detach();\n  }\n\n  /////////////////////////////////////////////////////////////////////////////\n  // User-Facing API\n  /////////////////////////////////////////////////////////////////////////////\n  \n  /**\n   *  Detach the controller from the terminal\n   */\n  detach(): void {\n    if (this.term && 'off' in this.term) {\n      this.term.off(\"data\", this._handleTermData);\n      this.term.off(\"resize\", this._handleTermResize);\n    } else {\n      this._disposables.forEach(d => d.dispose());\n      this._disposables = [];\n    }\n  }\n  \n  /**\n   * Attach controller to the terminal, handling events\n   */\n  attach(): void {\n    if (this.term && 'on' in this.term) {\n      this.term.on(\"data\", this._handleTermData);\n      this.term.on(\"resize\", this._handleTermResize);\n    } else if (this.term) {\n      this._disposables.push(this.term.onData(this._handleTermData));\n      this._disposables.push(this.term.onResize(this._handleTermResize));\n    }\n    this._termSize = {\n      cols: this.term ? this.term.cols : 0,\n      rows: this.term ? this.term.rows : 0,\n    };\n  }\n\n  /**\n   * Register a handler that will be called to satisfy auto-completion\n   */\n  addAutocompleteHandler(fn: Function, ...args: any[]): void {\n    this._autocompleteHandlers.push({\n      fn,\n      args\n    });\n  }\n\n  /**\n   * Remove a previously registered auto-complete handler\n   */\n  removeAutocompleteHandler(fn: Function): void {\n    const idx = this._autocompleteHandlers.findIndex(e => e.fn === fn);\n    if (idx === -1) return;\n\n    this._autocompleteHandlers.splice(idx, 1);\n  }\n\n  /**\n   * Return a promise that will resolve when the user has completed\n   * typing a single line\n   */\n  read(prompt: string, continuationPrompt: string = \"> \"): Promise<string> {\n    return new Promise((resolve, reject) => {\n      if (this.term) this.term.write(prompt);\n      this._activePrompt = {\n        prompt,\n        continuationPrompt,\n        resolve,\n        reject\n      };\n\n      this._input = \"\";\n      this._cursor = 0;\n      this._active = true;\n    });\n  }\n\n  /**\n   * Return a promise that will be resolved when the user types a single\n   * character.\n   *\n   * This can be active in addition to `.read()` and will be resolved in\n   * priority before it.\n   */\n  readChar(prompt: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n      if (this.term) this.term.write(prompt);\n      this._activeCharPrompt = {\n        prompt,\n        resolve,\n        reject\n      };\n    });\n  }\n\n  /**\n   * Abort a pending read operation\n   */\n  abortRead(reason: string = \"aborted\"): void {\n    if (this._activePrompt != null || this._activeCharPrompt != null) {\n      if (this.term) this.term.write(\"\\r\\n\");\n    }\n    if (this._activePrompt != null) {\n      this._activePrompt.reject(reason);\n      this._activePrompt = null;\n    }\n    if (this._activeCharPrompt != null) {\n      this._activeCharPrompt.reject(reason);\n      this._activeCharPrompt = null;\n    }\n    this._active = false;\n  }\n\n  /**\n   * Prints a message and changes line\n   */\n  println(message: string): void {\n    this.print(message + \"\\n\");\n  }\n\n  /**\n   * Prints a message and properly handles new-lines\n   */\n  print(message: string): void {\n    const normInput = message.replace(/[\\r\\n]+/g, \"\\n\");\n    if (this.term) this.term.write(normInput.replace(/\\n/g, \"\\r\\n\"));\n  }\n\n  /**\n   * Prints a list of items using a wide-format\n   */\n  printWide(items: string[], padding: number = 2): void {\n    if (items.length == 0) return this.println(\"\");\n\n    // Compute item sizes and matrix row/cols\n    const itemWidth =\n      items.reduce((width, item) => Math.max(width, item.length), 0) + padding;\n    const wideCols = Math.floor(this._termSize.cols / itemWidth);\n    const wideRows = Math.ceil(items.length / wideCols);\n\n    // Print matrix\n    let i = 0;\n    for (let row = 0; row < wideRows; ++row) {\n      let rowStr = \"\";\n\n      // Prepare columns\n      for (let col = 0; col < wideCols; ++col) {\n        if (i < items.length) {\n          let item = items[i++];\n          item += \" \".repeat(itemWidth - item.length);\n          rowStr += item;\n        }\n      }\n      this.println(rowStr);\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////////////\n  // Internal API\n  /////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Apply prompts to the given input\n   */\n  private applyPrompts(input: string): string {\n    const prompt = (this._activePrompt || {}).prompt || \"\";\n    const continuationPrompt =\n      (this._activePrompt || {}).continuationPrompt || \"\";\n\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\n  }\n\n  /**\n   * Advances the `offset` as required in order to accompany the prompt\n   * additions to the input.\n   */\n  private applyPromptOffset(input: string, offset: number): number {\n    const newInput = this.applyPrompts(input.substr(0, offset));\n    return newInput.length;\n  }\n\n  /**\n   * Clears the current prompt\n   *\n   * This function will erase all the lines that display the current prompt\n   * and move the cursor in the beginning of the first line of the prompt.\n   */\n  private clearInput(): void {\n    const currentPrompt = this.applyPrompts(this._input);\n\n    // Get the overall number of lines to clear\n    const allRows = countLines(currentPrompt, this._termSize.cols);\n\n    // Get the line we are currently in\n    const promptCursor = this.applyPromptOffset(this._input, this._cursor);\n    const { col, row } = offsetToColRow(\n      currentPrompt,\n      promptCursor,\n      this._termSize.cols\n    );\n\n    // First move on the last line\n    const moveRows = allRows - row - 1;\n    for (var i = 0; i < moveRows; ++i) {\n      if (this.term) this.term.write(\"\\x1B[E\");\n    }\n\n    // Clear current input line(s)\n    if (this.term) {\n      this.term.write(\"\\r\\x1B[K\");\n      for (var i = 1; i < allRows; ++i) this.term.write(\"\\x1B[F\\x1B[K\");\n    }\n  }\n\n  /**\n   * Replace input with the new input given\n   *\n   * This function clears all the lines that the current input occupies and\n   * then replaces them with the new input.\n   */\n  private setInput(newInput: string, clearInput: boolean = true): void {\n    // Clear current input\n    if (clearInput) this.clearInput();\n\n    // Write the new input lines, including the current prompt\n    const newPrompt = this.applyPrompts(newInput);\n    this.print(newPrompt);\n\n    // Trim cursor overflow\n    if (this._cursor > newInput.length) {\n      this._cursor = newInput.length;\n    }\n\n    // Move the cursor to the appropriate row/col\n    const newCursor = this.applyPromptOffset(newInput, this._cursor);\n    const newLines = countLines(newPrompt, this._termSize.cols);\n    const { col, row } = offsetToColRow(\n      newPrompt,\n      newCursor,\n      this._termSize.cols\n    );\n    const moveUpRows = newLines - row - 1;\n\n    if (this.term) {\n      this.term.write(\"\\r\");\n      for (var i = 0; i < moveUpRows; ++i) this.term.write(\"\\x1B[F\");\n      for (var i = 0; i < col; ++i) this.term.write(\"\\x1B[C\");\n    }\n\n    // Replace input\n    this._input = newInput;\n  }\n\n  /**\n   * This function completes the current input, calls the given callback\n   * and then re-displays the prompt.\n   */\n  private printAndRestartPrompt(callback: () => Promise<void> | void): void {\n    const cursor = this._cursor;\n\n    // Complete input\n    this.setCursor(this._input.length);\n    if (this.term) this.term.write(\"\\r\\n\");\n\n    // Prepare a function that will resume prompt\n    const resume = () => {\n      this._cursor = cursor;\n      this.setInput(this._input);\n    };\n\n    // Call the given callback to echo something, and if there is a promise\n    // returned, wait for the resolution before resuming prompt.\n    const ret = callback();\n    if (ret == null) {\n      resume();\n    } else {\n      ret.then(resume);\n    }\n  }\n\n  /**\n   * Set the new cursor position, as an offset on the input string\n   *\n   * This function:\n   * - Calculates the previous and current\n   */\n  private setCursor(newCursor: number): void {\n    if (newCursor < 0) newCursor = 0;\n    if (newCursor > this._input.length) newCursor = this._input.length;\n\n    // Apply prompt formatting to get the visual status of the display\n    const inputWithPrompt = this.applyPrompts(this._input);\n    const inputLines = countLines(inputWithPrompt, this._termSize.cols);\n\n    // Estimate previous cursor position\n    const prevPromptOffset = this.applyPromptOffset(this._input, this._cursor);\n    const { col: prevCol, row: prevRow } = offsetToColRow(\n      inputWithPrompt,\n      prevPromptOffset,\n      this._termSize.cols\n    );\n\n    // Estimate next cursor position\n    const newPromptOffset = this.applyPromptOffset(this._input, newCursor);\n    const { col: newCol, row: newRow } = offsetToColRow(\n      inputWithPrompt,\n      newPromptOffset,\n      this._termSize.cols\n    );\n\n    // Adjust vertically\n    if (this.term) {\n      if (newRow > prevRow) {\n        for (let i = prevRow; i < newRow; ++i) this.term.write(\"\\x1B[B\");\n      } else {\n        for (let i = newRow; i < prevRow; ++i) this.term.write(\"\\x1B[A\");\n      }\n\n      // Adjust horizontally\n      if (newCol > prevCol) {\n        for (let i = prevCol; i < newCol; ++i) this.term.write(\"\\x1B[C\");\n      } else {\n        for (let i = newCol; i < prevCol; ++i) this.term.write(\"\\x1B[D\");\n      }\n    }\n\n    // Set new offset\n    this._cursor = newCursor;\n  }\n\n  /**\n   * Move cursor at given direction\n   */\n  private handleCursorMove(dir: number): void {\n    if (dir > 0) {\n      const num = Math.min(dir, this._input.length - this._cursor);\n      this.setCursor(this._cursor + num);\n    } else if (dir < 0) {\n      const num = Math.max(dir, -this._cursor);\n      this.setCursor(this._cursor + num);\n    }\n  }\n\n  /**\n   * Erase a character at cursor location\n   */\n  private handleCursorErase(backspace: boolean): void {\n    const { _cursor, _input } = this;\n    if (backspace) {\n      if (_cursor <= 0) return;\n      const newInput = _input.substr(0, _cursor - 1) + _input.substr(_cursor);\n      this.clearInput();\n      this._cursor -= 1;\n      this.setInput(newInput, false);\n    } else {\n      const newInput = _input.substr(0, _cursor) + _input.substr(_cursor + 1);\n      this.setInput(newInput);\n    }\n  }\n\n  /**\n   * Insert character at cursor location\n   */\n  private handleCursorInsert(data: string): void {\n    const { _cursor, _input } = this;\n    const newInput = _input.substr(0, _cursor) + data + _input.substr(_cursor);\n    this._cursor += data.length;\n    this.setInput(newInput);\n  }\n\n  /**\n   * Handle input completion\n   */\n  private handleReadComplete(): void {\n    if (this.history) {\n      this.history.push(this._input);\n    }\n    if (this._activePrompt) {\n      this._activePrompt.resolve(this._input);\n      this._activePrompt = null;\n    }\n    if (this.term) this.term.write(\"\\r\\n\");\n    this._active = false;\n  }\n\n  /**\n   * Handle terminal resize\n   *\n   * This function clears the prompt using the previous configuration,\n   * updates the cached terminal size information and then re-renders the\n   * input. This leads (most of the times) into a better formatted input.\n   */\n  private handleTermResize(data: { rows: number; cols: number }): void {\n    const { rows, cols } = data;\n    this.clearInput();\n    this._termSize = { cols, rows };\n    this.setInput(this._input, false);\n  }\n\n  /**\n   * Handle terminal input\n   */\n  private handleTermData(data: string): void {\n    if (!this._active) return;\n\n    // If we have an active character prompt, satisfy it in priority\n    if (this._activeCharPrompt != null) {\n      this._activeCharPrompt.resolve(data);\n      this._activeCharPrompt = null;\n      if (this.term) this.term.write(\"\\r\\n\");\n      return;\n    }\n\n    // If this looks like a pasted input, expand it\n    if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\n      const normData = data.replace(/[\\r\\n]+/g, \"\\r\");\n      Array.from(normData).forEach(c => this.handleData(c));\n    } else {\n      this.handleData(data);\n    }\n  }\n\n  /**\n   * Handle a single piece of information from the terminal.\n   */\n  private handleData(data: string): void {\n    if (!this._active) return;\n    const ord = data.charCodeAt(0);\n    let ofs: number | null;\n\n    // Handle ANSI escape sequences\n    if (ord == 0x1b) {\n      switch (data.substr(1)) {\n        case \"[A\": // Up arrow\n          if (this.history) {\n            let value = this.history.getPrevious();\n            if (value) {\n              this.setInput(value);\n              this.setCursor(value.length);\n            }\n          }\n          break;\n\n        case \"[B\": // Down arrow\n          if (this.history) {\n            let value = this.history.getNext();\n            if (!value) value = \"\";\n            this.setInput(value);\n            this.setCursor(value.length);\n          }\n          break;\n\n        case \"[D\": // Left Arrow\n          this.handleCursorMove(-1);\n          break;\n\n        case \"[C\": // Right Arrow\n          this.handleCursorMove(1);\n          break;\n\n        case \"[3~\": // Delete\n          this.handleCursorErase(false);\n          break;\n\n        case \"[F\": // End\n          this.setCursor(this._input.length);\n          break;\n\n        case \"[H\": // Home\n          this.setCursor(0);\n          break;\n\n        case \"b\": // ALT + LEFT\n          ofs = closestLeftBoundary(this._input, this._cursor);\n          if (ofs != null) this.setCursor(ofs);\n          break;\n\n        case \"f\": // ALT + RIGHT\n          ofs = closestRightBoundary(this._input, this._cursor);\n          if (ofs != null) this.setCursor(ofs);\n          break;\n\n        case \"\\x7F\": // CTRL + BACKSPACE\n          ofs = closestLeftBoundary(this._input, this._cursor);\n          if (ofs != null) {\n            this.setInput(\n              this._input.substr(0, ofs) + this._input.substr(this._cursor)\n            );\n            this.setCursor(ofs);\n          }\n          break;\n      }\n\n      // Handle special characters\n    } else if (ord < 32 || ord === 0x7f) {\n      switch (data) {\n        case \"\\r\": // ENTER\n          if (isIncompleteInput(this._input)) {\n            this.handleCursorInsert(\"\\n\");\n          } else {\n            this.handleReadComplete();\n          }\n          break;\n\n        case \"\\x7F\": // BACKSPACE\n          this.handleCursorErase(true);\n          break;\n\n        case \"\\t\": // TAB\n          if (this._autocompleteHandlers.length > 0) {\n            const inputFragment = this._input.substr(0, this._cursor);\n            const hasTailingSpace = hasTailingWhitespace(inputFragment);\n            const candidates = collectAutocompleteCandidates(\n              this._autocompleteHandlers,\n              inputFragment\n            );\n\n            // Sort candidates\n            candidates.sort();\n\n            // Depending on the number of candidates, we are handling them in\n            // a different way.\n            if (candidates.length === 0) {\n              // No candidates? Just add a space if there is none already\n              if (!hasTailingSpace) {\n                this.handleCursorInsert(\" \");\n              }\n            } else if (candidates.length === 1) {\n              // Just a single candidate? Complete\n              const lastToken = getLastToken(inputFragment);\n              this.handleCursorInsert(\n                candidates[0].substr(lastToken.length) + \" \"\n              );\n            } else if (candidates.length <= this.maxAutocompleteEntries) {\n              // search for a shared fragment\n              const sharedFragment = getSharedFragment(inputFragment, candidates);\n              \n              // if there's a shared fragment between the candidates\n              // print complete the shared fragment\n              if (sharedFragment) {\n                const lastToken = getLastToken(inputFragment);\n                this.handleCursorInsert(\n                  sharedFragment.substr(lastToken.length)\n                );\n              }\n\n              // If we are less than maximum auto-complete candidates, print\n              // them to the user and re-start prompt\n              this.printAndRestartPrompt(() => {\n                this.printWide(candidates);\n              });\n            } else {\n              // If we have more than maximum auto-complete candidates, print\n              // them only if the user acknowledges a warning\n              this.printAndRestartPrompt(() =>\n                this.readChar(\n                  `Display all ${candidates.length} possibilities? (y or n)`\n                ).then(yn => {\n                  if (yn == \"y\" || yn == \"Y\") {\n                    this.printWide(candidates);\n                  }\n                })\n              );\n            }\n          } else {\n            this.handleCursorInsert(\"    \");\n          }\n          break;\n\n        case \"\\x03\": // CTRL+C\n          this.setCursor(this._input.length);\n          if (this.term) this.term.write(\"^C\\r\\n\" + ((this._activePrompt || {}).prompt || \"\"));\n          this._input = \"\";\n          this._cursor = 0;\n          if (this.history) this.history.rewind();\n          break;\n      }\n\n      // Handle visible characters\n    } else {\n      this.handleCursorInsert(data);\n    }\n  }\n}", "import LocalEchoController from \"./lib/LocalEchoController\";\nexport { HistoryController } from \"./lib/HistoryController\";\n\nexport default LocalEchoController;\n"],
  "mappings": "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",
  "names": ["require_quote", "__commonJSMin", "exports", "module", "xs", "s", "require_parse", "__commonJSMin", "exports", "module", "CONTROL", "controlRE", "META", "SINGLE_QUOTE", "DOUBLE_QUOTE", "hash", "SQ", "DQ", "DS", "TOKEN", "mult", "i", "startsWithToken", "matchAll", "s", "r", "origIndex", "matches", "matchObj", "getVar", "env", "pre", "key", "parseInternal", "string", "opts", "BS", "BAREWORD", "chunker", "commented", "match", "quote", "esc", "out", "isGlob", "parseEnvVar", "varend", "varname", "char", "slicedFromI", "commentObj", "prev", "arg", "mapped", "acc", "xs", "x", "require_shell_quote", "__commonJSMin", "exports", "HistoryController", "size", "entry", "lastEntry", "idx", "import_shell_quote", "wordBoundaries", "input", "leftSide", "match", "words", "rx", "closestLeftBoundary", "offset", "x", "closestRightBoundary", "offsetToColRow", "maxCols", "row", "col", "i", "countLines", "isIncompleteInput", "hasTailingWhitespace", "getLastToken", "collectAutocompleteCandidates", "callbacks", "tokens", "index", "expr", "candidates", "fn", "args", "e", "txt", "getSharedFragment", "fragment", "oldFragment", "LocalEchoController", "term", "options", "HistoryController", "d", "fn", "args", "idx", "e", "prompt", "continuationPrompt", "resolve", "reject", "reason", "message", "normInput", "items", "padding", "itemWidth", "width", "item", "wideCols", "wideRows", "i", "row", "rowStr", "col", "input", "offset", "currentPrompt", "allRows", "countLines", "promptCursor", "offsetToColRow", "moveRows", "newInput", "clearInput", "newPrompt", "newCursor", "newLines", "moveUpRows", "callback", "cursor", "resume", "ret", "inputWithPrompt", "inputLines", "prevPromptOffset", "prevCol", "prevRow", "newPromptOffset", "newCol", "newRow", "dir", "num", "backspace", "_cursor", "_input", "data", "rows", "cols", "normData", "c", "ord", "ofs", "value", "closestLeftBoundary", "closestRightBoundary", "isIncompleteInput", "inputFragment", "hasTailingSpace", "hasTailingWhitespace", "candidates", "collectAutocompleteCandidates", "lastToken", "getLastToken", "sharedFragment", "getSharedFragment", "yn", "local_echo_default", "LocalEchoController"]
}
