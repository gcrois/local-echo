{
  "version": 3,
  "sources": ["../node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/quote.js", "../node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/parse.js", "../node_modules/.pnpm/shell-quote@1.8.1/node_modules/shell-quote/index.js", "../lib/HistoryController.ts", "../lib/utils.ts", "../lib/LocalEchoController.ts", "../index.ts"],
  "sourcesContent": ["'use strict';\n\nmodule.exports = function quote(xs) {\n\treturn xs.map(function (s) {\n\t\tif (s && typeof s === 'object') {\n\t\t\treturn s.op.replace(/(.)/g, '\\\\$1');\n\t\t}\n\t\tif ((/[\"\\s]/).test(s) && !(/'/).test(s)) {\n\t\t\treturn \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n\t\t}\n\t\tif ((/[\"'\\s]/).test(s)) {\n\t\t\treturn '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n\t\t}\n\t\treturn String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@[\\\\\\]^`{|}])/g, '$1\\\\$2');\n\t}).join(' ');\n};\n", "'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|',\n\t'\\\\&\\\\&',\n\t';;',\n\t'\\\\|\\\\&',\n\t'\\\\<\\\\(',\n\t'\\\\<\\\\<\\\\<',\n\t'>>',\n\t'>\\\\&',\n\t'<\\\\&',\n\t'[&;()|<>]'\n].join('|') + ')';\nvar controlRE = new RegExp('^' + CONTROL + '$');\nvar META = '|&;()<> \\\\t';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar hash = /^#$/;\n\nvar SQ = \"'\";\nvar DQ = '\"';\nvar DS = '$';\n\nvar TOKEN = '';\nvar mult = 0x100000000; // Math.pow(16, 8);\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (mult * Math.random()).toString(16);\n}\nvar startsWithToken = new RegExp('^' + TOKEN);\n\nfunction matchAll(s, r) {\n\tvar origIndex = r.lastIndex;\n\n\tvar matches = [];\n\tvar matchObj;\n\n\twhile ((matchObj = r.exec(s))) {\n\t\tmatches.push(matchObj);\n\t\tif (r.lastIndex === matchObj.index) {\n\t\t\tr.lastIndex += 1;\n\t\t}\n\t}\n\n\tr.lastIndex = origIndex;\n\n\treturn matches;\n}\n\nfunction getVar(env, pre, key) {\n\tvar r = typeof env === 'function' ? env(key) : env[key];\n\tif (typeof r === 'undefined' && key != '') {\n\t\tr = '';\n\t} else if (typeof r === 'undefined') {\n\t\tr = '$';\n\t}\n\n\tif (typeof r === 'object') {\n\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t}\n\treturn pre + r;\n}\n\nfunction parseInternal(string, env, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tvar BS = opts.escape || '\\\\';\n\tvar BAREWORD = '(\\\\' + BS + '[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'\n\t].join('|'), 'g');\n\n\tvar matches = matchAll(string, chunker);\n\n\tif (matches.length === 0) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\n\tvar commented = false;\n\n\treturn matches.map(function (match) {\n\t\tvar s = match[0];\n\t\tif (!s || commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (controlRE.test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\tvar char = s.charAt(i);\n\n\t\t\tif (char === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i - 2, i + 1));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.slice(i, varend);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(char)) {\n\t\t\t\tvarname = char;\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar slicedFromI = s.slice(i);\n\t\t\t\tvarend = slicedFromI.match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = slicedFromI;\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = slicedFromI.slice(0, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(env, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (controlRE.test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if (hash.test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tvar commentObj = { comment: string.slice(match.index + i + 1) };\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, commentObj];\n\t\t\t\t}\n\t\t\t\treturn [commentObj];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed arguments\n\t\t// TODO: replace this whole reduce with a concat\n\t\treturn typeof arg === 'undefined' ? prev : prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (startsWithToken.test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n", "'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n", "/**\n * The history controller provides a ring-buffer\n */\nexport class HistoryController {\n\tprivate size: number;\n\tprivate entries: string[];\n\tprivate cursor: number;\n\n\tconstructor(size: number) {\n\t\tthis.size = size;\n\t\tthis.entries = [];\n\t\tthis.cursor = 0;\n\t}\n\n\t/**\n\t * Push an entry and maintain ring buffer size\n\t */\n\tpush(entry: string): void {\n\t\t// Skip empty entries\n\t\tif (entry.trim() === \"\") return;\n\n\t\t// Skip duplicate entries\n\t\tconst lastEntry = this.entries[this.entries.length - 1];\n\t\tif (entry === lastEntry) return;\n\n\t\t// Keep track of entries\n\t\tthis.entries.push(entry);\n\t\tif (this.entries.length > this.size) {\n\t\t\tthis.entries.shift();\n\t\t}\n\t\tthis.cursor = this.entries.length;\n\t}\n\n\t/**\n\t * Rewind history cursor to the last entry\n\t */\n\trewind(): void {\n\t\tthis.cursor = this.entries.length;\n\t}\n\n\t/**\n\t * Returns the previous entry\n\t */\n\tgetPrevious(): string | undefined {\n\t\tconst idx = Math.max(0, this.cursor - 1);\n\t\tthis.cursor = idx;\n\t\treturn this.entries[idx];\n\t}\n\n\t/**\n\t * Returns the next entry\n\t */\n\tgetNext(): string | undefined {\n\t\tconst idx = Math.min(this.entries.length, this.cursor + 1);\n\t\tthis.cursor = idx;\n\t\treturn this.entries[idx];\n\t}\n}\n", "import { parse, ParseEntry } from \"shell-quote\";\n\n/**\n * Detects all the word boundaries in the given input.\n */\nexport function wordBoundaries(\n\tinput: string,\n\tleftSide: boolean = true,\n): number[] {\n\tlet match: RegExpExecArray | null;\n\tconst words: number[] = [];\n\tconst rx: RegExp = /\\w+/g;\n\n\twhile ((match = rx.exec(input))) {\n\t\twords.push(leftSide ? match.index : match.index + match[0].length);\n\t}\n\n\treturn words;\n}\n\n/**\n * Finds the closest left word boundary of the given input at the given offset.\n */\nexport function closestLeftBoundary(input: string, offset: number): number {\n\tconst found = wordBoundaries(input, true)\n\t\t.reverse()\n\t\t.find((x) => x < offset);\n\treturn found ?? 0;\n}\n\n/**\n * Finds the closest right word boundary of the given input at the given offset.\n */\nexport function closestRightBoundary(input: string, offset: number): number {\n\tconst found = wordBoundaries(input, false).find((x) => x > offset);\n\treturn found ?? input.length;\n}\n\n/**\n * Converts an offset in the given input to a column/row location.\n */\nexport function offsetToColRow(\n\tinput: string,\n\toffset: number,\n\tmaxCols: number,\n): { row: number; col: number } {\n\tlet row = 0,\n\t\tcol = 0;\n\n\tfor (let i = 0; i < offset; ++i) {\n\t\tconst chr = input.charAt(i);\n\t\tif (chr === \"\\n\") {\n\t\t\tcol = 0;\n\t\t\trow += 1;\n\t\t} else {\n\t\t\tcol += 1;\n\t\t\tif (col > maxCols) {\n\t\t\t\tcol = 0;\n\t\t\t\trow += 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { row, col };\n}\n\n/**\n * Counts the lines in the given input.\n */\nexport function countLines(input: string, maxCols: number): number {\n\treturn offsetToColRow(input, input.length, maxCols).row + 1;\n}\n\n/**\n * Checks if there is an incomplete input.\n */\nexport function isIncompleteInput(input: string): boolean {\n\tif (input.trim() === \"\") {\n\t\treturn false;\n\t}\n\n\tif ((input.match(/'/g) || []).length % 2 !== 0) {\n\t\treturn true;\n\t}\n\n\tif ((input.match(/\"/g) || []).length % 2 !== 0) {\n\t\treturn true;\n\t}\n\n\tif (\n\t\tinput\n\t\t\t.split(/(\\|\\||\\||&&)/g)\n\t\t\t.pop()\n\t\t\t?.trim() === \"\"\n\t) {\n\t\treturn true;\n\t}\n\n\treturn input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\");\n}\n\n/**\n * Checks if the input ends with trailing whitespace.\n */\nexport function hasTailingWhitespace(input: string): boolean {\n\treturn /[^\\\\][ \\t]$/m.test(input);\n}\n\n/**\n * Returns the last token in the given input.\n */\nexport function getLastToken(input: string): string {\n\tif (input.trim() === \"\" || hasTailingWhitespace(input)) {\n\t\treturn \"\";\n\t}\n\n\tconst tokens = parse(input) as string[];\n\treturn tokens.pop() || \"\";\n}\n\n/**\n * Collects autocomplete candidates based on the input and callback functions.\n */\nexport function collectAutocompleteCandidates(\n\tcallbacks: {\n\t\tfn: (index: number, tokens: string[], ...args: unknown[]) => string[];\n\t\targs: unknown[];\n\t}[],\n\tinput: string,\n): string[] {\n\tconst tokens = parse(input) as string[];\n\tlet index = tokens.length - 1;\n\tlet expr = tokens[index] || \"\";\n\n\tif (input.trim() === \"\") {\n\t\tindex = 0;\n\t\texpr = \"\";\n\t} else if (hasTailingWhitespace(input)) {\n\t\tindex += 1;\n\t\texpr = \"\";\n\t}\n\n\treturn callbacks\n\t\t.reduce<string[]>((candidates, { fn, args }) => {\n\t\t\ttry {\n\t\t\t\treturn candidates.concat(fn(index, tokens, ...args));\n\t\t\t} catch (e) {\n\t\t\t\tconsole.error(\"Auto-complete error:\", e);\n\t\t\t\treturn candidates;\n\t\t\t}\n\t\t}, [])\n\t\t.filter((txt) => txt.startsWith(expr));\n}\n\n/**\n * Returns the longest common starting substring in a list of strings.\n */\nexport function getSharedFragment(\n\tfragment: string,\n\tcandidates: string[],\n): string | null {\n\tif (fragment.length >= candidates[0].length) return fragment;\n\n\tconst oldFragment = fragment;\n\tfragment += candidates[0].slice(fragment.length, fragment.length + 1);\n\n\tfor (let i = 0; i < candidates.length; i++) {\n\t\tif (!candidates[i].startsWith(oldFragment)) return null;\n\t\tif (!candidates[i].startsWith(fragment)) {\n\t\t\treturn oldFragment;\n\t\t}\n\t}\n\n\treturn getSharedFragment(fragment, candidates);\n}\n", "import { HistoryController } from \"./HistoryController\";\nimport {\n\tclosestLeftBoundary,\n\tclosestRightBoundary,\n\tcollectAutocompleteCandidates,\n\tcountLines,\n\tgetLastToken,\n\thasTailingWhitespace,\n\tisIncompleteInput,\n\toffsetToColRow,\n\tgetSharedFragment,\n} from \"./utils\";\nimport { Terminal } from \"@xterm/xterm\";\n\ninterface LocalEchoControllerOptions {\n\thistorySize?: number;\n\tmaxAutocompleteEntries?: number;\n}\n\ninterface TermSize {\n\tcols: number;\n\trows: number;\n}\n\ninterface ActivePrompt {\n\tprompt: string;\n\tcontinuationPrompt: string;\n\tresolve: (value: string) => void;\n\treject: (reason?: any) => void;\n}\n\ninterface ActiveCharPrompt {\n\tprompt: string;\n\tresolve: (value: string) => void;\n\treject: (reason?: any) => void;\n}\n\ninterface AutocompleteHandler {\n\tfn: Function;\n\targs: any[];\n}\n\n/**\n * A local terminal controller is responsible for displaying messages\n * and handling local echo for the terminal.\n *\n * Local echo supports most of bash-like input primitives. Namely:\n * - Arrow navigation on the input\n * - Alt-arrow for word-boundary navigation\n * - Alt-backspace for word-boundary deletion\n * - Multi-line input for incomplete commands\n * - Auto-complete hooks\n */\nexport default class LocalEchoController {\n\tprivate term: Terminal | null;\n\tprivate history: HistoryController;\n\tprivate maxAutocompleteEntries: number;\n\tprivate _autocompleteHandlers: AutocompleteHandler[];\n\tprivate _active: boolean;\n\tprivate _input: string;\n\tprivate _cursor: number;\n\tprivate _activePrompt: ActivePrompt | null;\n\tprivate _activeCharPrompt: ActiveCharPrompt | null;\n\tprivate _termSize: TermSize;\n\tprivate _disposables: { dispose: () => void }[];\n\tprivate _handleTermData: (data: string) => void;\n\tprivate _handleTermResize: (data: { rows: number; cols: number }) => void;\n\n\tconstructor(\n\t\tterm: Terminal | null = null,\n\t\toptions: LocalEchoControllerOptions = {},\n\t) {\n\t\tthis.term = term;\n\t\tthis._handleTermData = this.handleTermData.bind(this);\n\t\tthis._handleTermResize = this.handleTermResize.bind(this);\n\n\t\tthis.history = new HistoryController(options.historySize || 10);\n\t\tthis.maxAutocompleteEntries = options.maxAutocompleteEntries || 100;\n\n\t\tthis._autocompleteHandlers = [];\n\t\tthis._active = false;\n\t\tthis._input = \"\";\n\t\tthis._cursor = 0;\n\t\tthis._activePrompt = null;\n\t\tthis._activeCharPrompt = null;\n\t\tthis._termSize = {\n\t\t\tcols: 0,\n\t\t\trows: 0,\n\t\t};\n\n\t\tthis._disposables = [];\n\n\t\tif (term) {\n\t\t\tif (\"loadAddon\" in term) term.loadAddon(this);\n\t\t\telse this.attach();\n\t\t}\n\t}\n\n\t// xterm.js new plugin API:\n\tactivate(term: Terminal): void {\n\t\tthis.term = term;\n\t\tthis.attach();\n\t}\n\n\tdispose(): void {\n\t\tthis.detach();\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////\n\t// User-Facing API\n\t/////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t *  Detach the controller from the terminal\n\t */\n\tdetach(): void {\n\t\tif (this.term && \"off\" in this.term) {\n\t\t\tthis.term.off(\"data\", this._handleTermData);\n\t\t\tthis.term.off(\"resize\", this._handleTermResize);\n\t\t} else {\n\t\t\tthis._disposables.forEach((d) => d.dispose());\n\t\t\tthis._disposables = [];\n\t\t}\n\t}\n\n\t/**\n\t * Attach controller to the terminal, handling events\n\t */\n\tattach(): void {\n\t\tif (this.term && \"on\" in this.term) {\n\t\t\tthis.term.on(\"data\", this._handleTermData);\n\t\t\tthis.term.on(\"resize\", this._handleTermResize);\n\t\t} else if (this.term) {\n\t\t\tthis._disposables.push(this.term.onData(this._handleTermData));\n\t\t\tthis._disposables.push(this.term.onResize(this._handleTermResize));\n\t\t}\n\t\tthis._termSize = {\n\t\t\tcols: this.term ? this.term.cols : 0,\n\t\t\trows: this.term ? this.term.rows : 0,\n\t\t};\n\t}\n\n\t/**\n\t * Register a handler that will be called to satisfy auto-completion\n\t */\n\taddAutocompleteHandler(fn: Function, ...args: any[]): void {\n\t\tthis._autocompleteHandlers.push({\n\t\t\tfn,\n\t\t\targs,\n\t\t});\n\t}\n\n\t/**\n\t * Remove a previously registered auto-complete handler\n\t */\n\tremoveAutocompleteHandler(fn: Function): void {\n\t\tconst idx = this._autocompleteHandlers.findIndex((e) => e.fn === fn);\n\t\tif (idx === -1) return;\n\n\t\tthis._autocompleteHandlers.splice(idx, 1);\n\t}\n\n\t/**\n\t * Return a promise that will resolve when the user has completed\n\t * typing a single line\n\t */\n\tread(prompt: string, continuationPrompt: string = \"> \"): Promise<string> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (this.term) this.term.write(prompt);\n\t\t\tthis._activePrompt = {\n\t\t\t\tprompt,\n\t\t\t\tcontinuationPrompt,\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t};\n\n\t\t\tthis._input = \"\";\n\t\t\tthis._cursor = 0;\n\t\t\tthis._active = true;\n\t\t});\n\t}\n\n\t/**\n\t * Return a promise that will be resolved when the user types a single\n\t * character.\n\t *\n\t * This can be active in addition to `.read()` and will be resolved in\n\t * priority before it.\n\t */\n\treadChar(prompt: string): Promise<string> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (this.term) this.term.write(prompt);\n\t\t\tthis._activeCharPrompt = {\n\t\t\t\tprompt,\n\t\t\t\tresolve,\n\t\t\t\treject,\n\t\t\t};\n\t\t});\n\t}\n\n\t/**\n\t * Abort a pending read operation\n\t */\n\tabortRead(reason: string = \"aborted\"): void {\n\t\tif (this._activePrompt != null || this._activeCharPrompt != null) {\n\t\t\tif (this.term) this.term.write(\"\\r\\n\");\n\t\t}\n\t\tif (this._activePrompt != null) {\n\t\t\tthis._activePrompt.reject(reason);\n\t\t\tthis._activePrompt = null;\n\t\t}\n\t\tif (this._activeCharPrompt != null) {\n\t\t\tthis._activeCharPrompt.reject(reason);\n\t\t\tthis._activeCharPrompt = null;\n\t\t}\n\t\tthis._active = false;\n\t}\n\n\t/**\n\t * Prints a message and changes line\n\t */\n\tprintln(message: string): void {\n\t\tthis.print(message + \"\\n\");\n\t}\n\n\t/**\n\t * Prints a message and properly handles new-lines\n\t */\n\tprint(message: string): void {\n\t\tconst normInput = message.replace(/[\\r\\n]+/g, \"\\n\");\n\t\tif (this.term) this.term.write(normInput.replace(/\\n/g, \"\\r\\n\"));\n\t}\n\n\t/**\n\t * Prints a list of items using a wide-format\n\t */\n\tprintWide(items: string[], padding: number = 2): void {\n\t\tif (items.length == 0) return this.println(\"\");\n\n\t\t// Compute item sizes and matrix row/cols\n\t\tconst itemWidth =\n\t\t\titems.reduce((width, item) => Math.max(width, item.length), 0) +\n\t\t\tpadding;\n\t\tconst wideCols = Math.floor(this._termSize.cols / itemWidth);\n\t\tconst wideRows = Math.ceil(items.length / wideCols);\n\n\t\t// Print matrix\n\t\tlet i = 0;\n\t\tfor (let row = 0; row < wideRows; ++row) {\n\t\t\tlet rowStr = \"\";\n\n\t\t\t// Prepare columns\n\t\t\tfor (let col = 0; col < wideCols; ++col) {\n\t\t\t\tif (i < items.length) {\n\t\t\t\t\tlet item = items[i++];\n\t\t\t\t\titem += \" \".repeat(itemWidth - item.length);\n\t\t\t\t\trowStr += item;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.println(rowStr);\n\t\t}\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////\n\t// Internal API\n\t/////////////////////////////////////////////////////////////////////////////\n\n\t/**\n\t * Apply prompts to the given input\n\t */\n\tprivate applyPrompts(input: string): string {\n\t\tconst prompt = (this._activePrompt || {}).prompt || \"\";\n\t\tconst continuationPrompt =\n\t\t\t(this._activePrompt || {}).continuationPrompt || \"\";\n\n\t\treturn prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\n\t}\n\n\t/**\n\t * Advances the `offset` as required in order to accompany the prompt\n\t * additions to the input.\n\t */\n\tprivate applyPromptOffset(input: string, offset: number): number {\n\t\tconst newInput = this.applyPrompts(input.substr(0, offset));\n\t\treturn newInput.length;\n\t}\n\n\t/**\n\t * Clears the current prompt\n\t *\n\t * This function will erase all the lines that display the current prompt\n\t * and move the cursor in the beginning of the first line of the prompt.\n\t */\n\tprivate clearInput(): void {\n\t\tconst currentPrompt = this.applyPrompts(this._input);\n\n\t\t// Get the overall number of lines to clear\n\t\tconst allRows = countLines(currentPrompt, this._termSize.cols);\n\n\t\t// Get the line we are currently in\n\t\tconst promptCursor = this.applyPromptOffset(this._input, this._cursor);\n\t\tconst { col, row } = offsetToColRow(\n\t\t\tcurrentPrompt,\n\t\t\tpromptCursor,\n\t\t\tthis._termSize.cols,\n\t\t);\n\n\t\t// First move on the last line\n\t\tconst moveRows = allRows - row - 1;\n\t\tfor (var i = 0; i < moveRows; ++i) {\n\t\t\tif (this.term) this.term.write(\"\\x1B[E\");\n\t\t}\n\n\t\t// Clear current input line(s)\n\t\tif (this.term) {\n\t\t\tthis.term.write(\"\\r\\x1B[K\");\n\t\t\tfor (var i = 1; i < allRows; ++i) this.term.write(\"\\x1B[F\\x1B[K\");\n\t\t}\n\t}\n\n\t/**\n\t * Replace input with the new input given\n\t *\n\t * This function clears all the lines that the current input occupies and\n\t * then replaces them with the new input.\n\t */\n\tprivate setInput(newInput: string, clearInput: boolean = true): void {\n\t\t// Clear current input\n\t\tif (clearInput) this.clearInput();\n\n\t\t// Write the new input lines, including the current prompt\n\t\tconst newPrompt = this.applyPrompts(newInput);\n\t\tthis.print(newPrompt);\n\n\t\t// Trim cursor overflow\n\t\tif (this._cursor > newInput.length) {\n\t\t\tthis._cursor = newInput.length;\n\t\t}\n\n\t\t// Move the cursor to the appropriate row/col\n\t\tconst newCursor = this.applyPromptOffset(newInput, this._cursor);\n\t\tconst newLines = countLines(newPrompt, this._termSize.cols);\n\t\tconst { col, row } = offsetToColRow(\n\t\t\tnewPrompt,\n\t\t\tnewCursor,\n\t\t\tthis._termSize.cols,\n\t\t);\n\t\tconst moveUpRows = newLines - row - 1;\n\n\t\tif (this.term) {\n\t\t\tthis.term.write(\"\\r\");\n\t\t\tfor (var i = 0; i < moveUpRows; ++i) this.term.write(\"\\x1B[F\");\n\t\t\tfor (var i = 0; i < col; ++i) this.term.write(\"\\x1B[C\");\n\t\t}\n\n\t\t// Replace input\n\t\tthis._input = newInput;\n\t}\n\n\t/**\n\t * This function completes the current input, calls the given callback\n\t * and then re-displays the prompt.\n\t */\n\tprivate printAndRestartPrompt(callback: () => Promise<void> | void): void {\n\t\tconst cursor = this._cursor;\n\n\t\t// Complete input\n\t\tthis.setCursor(this._input.length);\n\t\tif (this.term) this.term.write(\"\\r\\n\");\n\n\t\t// Prepare a function that will resume prompt\n\t\tconst resume = () => {\n\t\t\tthis._cursor = cursor;\n\t\t\tthis.setInput(this._input);\n\t\t};\n\n\t\t// Call the given callback to echo something, and if there is a promise\n\t\t// returned, wait for the resolution before resuming prompt.\n\t\tconst ret = callback();\n\t\tif (ret == null) {\n\t\t\tresume();\n\t\t} else {\n\t\t\tret.then(resume);\n\t\t}\n\t}\n\n\t/**\n\t * Set the new cursor position, as an offset on the input string\n\t *\n\t * This function:\n\t * - Calculates the previous and current\n\t */\n\tprivate setCursor(newCursor: number): void {\n\t\tif (newCursor < 0) newCursor = 0;\n\t\tif (newCursor > this._input.length) newCursor = this._input.length;\n\n\t\t// Apply prompt formatting to get the visual status of the display\n\t\tconst inputWithPrompt = this.applyPrompts(this._input);\n\t\tconst inputLines = countLines(inputWithPrompt, this._termSize.cols);\n\n\t\t// Estimate previous cursor position\n\t\tconst prevPromptOffset = this.applyPromptOffset(\n\t\t\tthis._input,\n\t\t\tthis._cursor,\n\t\t);\n\t\tconst { col: prevCol, row: prevRow } = offsetToColRow(\n\t\t\tinputWithPrompt,\n\t\t\tprevPromptOffset,\n\t\t\tthis._termSize.cols,\n\t\t);\n\n\t\t// Estimate next cursor position\n\t\tconst newPromptOffset = this.applyPromptOffset(this._input, newCursor);\n\t\tconst { col: newCol, row: newRow } = offsetToColRow(\n\t\t\tinputWithPrompt,\n\t\t\tnewPromptOffset,\n\t\t\tthis._termSize.cols,\n\t\t);\n\n\t\t// Adjust vertically\n\t\tif (this.term) {\n\t\t\tif (newRow > prevRow) {\n\t\t\t\tfor (let i = prevRow; i < newRow; ++i)\n\t\t\t\t\tthis.term.write(\"\\x1B[B\");\n\t\t\t} else {\n\t\t\t\tfor (let i = newRow; i < prevRow; ++i)\n\t\t\t\t\tthis.term.write(\"\\x1B[A\");\n\t\t\t}\n\n\t\t\t// Adjust horizontally\n\t\t\tif (newCol > prevCol) {\n\t\t\t\tfor (let i = prevCol; i < newCol; ++i)\n\t\t\t\t\tthis.term.write(\"\\x1B[C\");\n\t\t\t} else {\n\t\t\t\tfor (let i = newCol; i < prevCol; ++i)\n\t\t\t\t\tthis.term.write(\"\\x1B[D\");\n\t\t\t}\n\t\t}\n\n\t\t// Set new offset\n\t\tthis._cursor = newCursor;\n\t}\n\n\t/**\n\t * Move cursor at given direction\n\t */\n\tprivate handleCursorMove(dir: number): void {\n\t\tif (dir > 0) {\n\t\t\tconst num = Math.min(dir, this._input.length - this._cursor);\n\t\t\tthis.setCursor(this._cursor + num);\n\t\t} else if (dir < 0) {\n\t\t\tconst num = Math.max(dir, -this._cursor);\n\t\t\tthis.setCursor(this._cursor + num);\n\t\t}\n\t}\n\n\t/**\n\t * Erase a character at cursor location\n\t */\n\tprivate handleCursorErase(backspace: boolean): void {\n\t\tconst { _cursor, _input } = this;\n\t\tif (backspace) {\n\t\t\tif (_cursor <= 0) return;\n\t\t\tconst newInput =\n\t\t\t\t_input.substr(0, _cursor - 1) + _input.substr(_cursor);\n\t\t\tthis.clearInput();\n\t\t\tthis._cursor -= 1;\n\t\t\tthis.setInput(newInput, false);\n\t\t} else {\n\t\t\tconst newInput =\n\t\t\t\t_input.substr(0, _cursor) + _input.substr(_cursor + 1);\n\t\t\tthis.setInput(newInput);\n\t\t}\n\t}\n\n\t/**\n\t * Insert character at cursor location\n\t */\n\tprivate handleCursorInsert(data: string): void {\n\t\tconst { _cursor, _input } = this;\n\t\tconst newInput =\n\t\t\t_input.substr(0, _cursor) + data + _input.substr(_cursor);\n\t\tthis._cursor += data.length;\n\t\tthis.setInput(newInput);\n\t}\n\n\t/**\n\t * Handle input completion\n\t */\n\tprivate handleReadComplete(): void {\n\t\tif (this.history) {\n\t\t\tthis.history.push(this._input);\n\t\t}\n\t\tif (this._activePrompt) {\n\t\t\tthis._activePrompt.resolve(this._input);\n\t\t\tthis._activePrompt = null;\n\t\t}\n\t\tif (this.term) this.term.write(\"\\r\\n\");\n\t\tthis._active = false;\n\t}\n\n\t/**\n\t * Handle terminal resize\n\t *\n\t * This function clears the prompt using the previous configuration,\n\t * updates the cached terminal size information and then re-renders the\n\t * input. This leads (most of the times) into a better formatted input.\n\t */\n\tprivate handleTermResize(data: { rows: number; cols: number }): void {\n\t\tconst { rows, cols } = data;\n\t\tthis.clearInput();\n\t\tthis._termSize = { cols, rows };\n\t\tthis.setInput(this._input, false);\n\t}\n\n\t/**\n\t * Handle terminal input\n\t */\n\tprivate handleTermData(data: string): void {\n\t\tif (!this._active) return;\n\n\t\t// If we have an active character prompt, satisfy it in priority\n\t\tif (this._activeCharPrompt != null) {\n\t\t\tthis._activeCharPrompt.resolve(data);\n\t\t\tthis._activeCharPrompt = null;\n\t\t\tif (this.term) this.term.write(\"\\r\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\t// If this looks like a pasted input, expand it\n\t\tif (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\n\t\t\tconst normData = data.replace(/[\\r\\n]+/g, \"\\r\");\n\t\t\tArray.from(normData).forEach((c) => this.handleData(c));\n\t\t} else {\n\t\t\tthis.handleData(data);\n\t\t}\n\t}\n\n\t/**\n\t * Handle a single piece of information from the terminal.\n\t */\n\tprivate handleData(data: string): void {\n\t\tif (!this._active) return;\n\t\tconst ord = data.charCodeAt(0);\n\t\tlet ofs: number | null;\n\n\t\t// Handle ANSI escape sequences\n\t\tif (ord == 0x1b) {\n\t\t\tswitch (data.substr(1)) {\n\t\t\t\tcase \"[A\": // Up arrow\n\t\t\t\t\tif (this.history) {\n\t\t\t\t\t\tlet value = this.history.getPrevious();\n\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\tthis.setInput(value);\n\t\t\t\t\t\t\tthis.setCursor(value.length);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"[B\": // Down arrow\n\t\t\t\t\tif (this.history) {\n\t\t\t\t\t\tlet value = this.history.getNext();\n\t\t\t\t\t\tif (!value) value = \"\";\n\t\t\t\t\t\tthis.setInput(value);\n\t\t\t\t\t\tthis.setCursor(value.length);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"[D\": // Left Arrow\n\t\t\t\t\tthis.handleCursorMove(-1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"[C\": // Right Arrow\n\t\t\t\t\tthis.handleCursorMove(1);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"[3~\": // Delete\n\t\t\t\t\tthis.handleCursorErase(false);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"[F\": // End\n\t\t\t\t\tthis.setCursor(this._input.length);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"[H\": // Home\n\t\t\t\t\tthis.setCursor(0);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"b\": // ALT + LEFT\n\t\t\t\t\tofs = closestLeftBoundary(this._input, this._cursor);\n\t\t\t\t\tif (ofs != null) this.setCursor(ofs);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"f\": // ALT + RIGHT\n\t\t\t\t\tofs = closestRightBoundary(this._input, this._cursor);\n\t\t\t\t\tif (ofs != null) this.setCursor(ofs);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"\\x7F\": // CTRL + BACKSPACE\n\t\t\t\t\tofs = closestLeftBoundary(this._input, this._cursor);\n\t\t\t\t\tif (ofs != null) {\n\t\t\t\t\t\tthis.setInput(\n\t\t\t\t\t\t\tthis._input.substr(0, ofs) +\n\t\t\t\t\t\t\t\tthis._input.substr(this._cursor),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthis.setCursor(ofs);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Handle special characters\n\t\t} else if (ord < 32 || ord === 0x7f) {\n\t\t\tswitch (data) {\n\t\t\t\tcase \"\\r\": // ENTER\n\t\t\t\t\tif (isIncompleteInput(this._input)) {\n\t\t\t\t\t\tthis.handleCursorInsert(\"\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.handleReadComplete();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"\\x7F\": // BACKSPACE\n\t\t\t\t\tthis.handleCursorErase(true);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"\\t\": // TAB\n\t\t\t\t\tif (this._autocompleteHandlers.length > 0) {\n\t\t\t\t\t\tconst inputFragment = this._input.substr(\n\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\tthis._cursor,\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst hasTailingSpace =\n\t\t\t\t\t\t\thasTailingWhitespace(inputFragment);\n\t\t\t\t\t\tconst candidates = collectAutocompleteCandidates(\n\t\t\t\t\t\t\tthis._autocompleteHandlers,\n\t\t\t\t\t\t\tinputFragment,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Sort candidates\n\t\t\t\t\t\tcandidates.sort();\n\n\t\t\t\t\t\t// Depending on the number of candidates, we are handling them in\n\t\t\t\t\t\t// a different way.\n\t\t\t\t\t\tif (candidates.length === 0) {\n\t\t\t\t\t\t\t// No candidates? Just add a space if there is none already\n\t\t\t\t\t\t\tif (!hasTailingSpace) {\n\t\t\t\t\t\t\t\tthis.handleCursorInsert(\" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (candidates.length === 1) {\n\t\t\t\t\t\t\t// Just a single candidate? Complete\n\t\t\t\t\t\t\tconst lastToken = getLastToken(inputFragment);\n\t\t\t\t\t\t\tthis.handleCursorInsert(\n\t\t\t\t\t\t\t\tcandidates[0].substr(lastToken.length) + \" \",\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\tcandidates.length <= this.maxAutocompleteEntries\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// search for a shared fragment\n\t\t\t\t\t\t\tconst sharedFragment = getSharedFragment(\n\t\t\t\t\t\t\t\tinputFragment,\n\t\t\t\t\t\t\t\tcandidates,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t// if there's a shared fragment between the candidates\n\t\t\t\t\t\t\t// print complete the shared fragment\n\t\t\t\t\t\t\tif (sharedFragment) {\n\t\t\t\t\t\t\t\tconst lastToken = getLastToken(inputFragment);\n\t\t\t\t\t\t\t\tthis.handleCursorInsert(\n\t\t\t\t\t\t\t\t\tsharedFragment.substr(lastToken.length),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// If we are less than maximum auto-complete candidates, print\n\t\t\t\t\t\t\t// them to the user and re-start prompt\n\t\t\t\t\t\t\tthis.printAndRestartPrompt(() => {\n\t\t\t\t\t\t\t\tthis.printWide(candidates);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// If we have more than maximum auto-complete candidates, print\n\t\t\t\t\t\t\t// them only if the user acknowledges a warning\n\t\t\t\t\t\t\tthis.printAndRestartPrompt(() =>\n\t\t\t\t\t\t\t\tthis.readChar(\n\t\t\t\t\t\t\t\t\t`Display all ${candidates.length} possibilities? (y or n)`,\n\t\t\t\t\t\t\t\t).then((yn) => {\n\t\t\t\t\t\t\t\t\tif (yn == \"y\" || yn == \"Y\") {\n\t\t\t\t\t\t\t\t\t\tthis.printWide(candidates);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.handleCursorInsert(\"    \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"\\x03\": // CTRL+C\n\t\t\t\t\tthis.setCursor(this._input.length);\n\t\t\t\t\tif (this.term)\n\t\t\t\t\t\tthis.term.write(\n\t\t\t\t\t\t\t\"^C\\r\\n\" +\n\t\t\t\t\t\t\t\t((this._activePrompt || {}).prompt || \"\"),\n\t\t\t\t\t\t);\n\t\t\t\t\tthis._input = \"\";\n\t\t\t\t\tthis._cursor = 0;\n\t\t\t\t\tif (this.history) this.history.rewind();\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Handle visible characters\n\t\t} else {\n\t\t\tthis.handleCursorInsert(data);\n\t\t}\n\t}\n}\n", "import LocalEchoController from \"./lib/LocalEchoController\";\nexport { HistoryController } from \"./lib/HistoryController\";\n\nexport default LocalEchoController;\n"],
  "mappings": "shBAAA,IAAAA,EAAAC,EAAA,CAAAC,GAAAC,IAAA,cAEAA,EAAO,QAAU,SAAeC,EAAI,CACnC,OAAOA,EAAG,IAAI,SAAUC,EAAG,CAC1B,OAAIA,GAAK,OAAOA,GAAM,SACdA,EAAE,GAAG,QAAQ,OAAQ,MAAM,EAE9B,QAAS,KAAKA,CAAC,GAAK,CAAE,IAAK,KAAKA,CAAC,EAC9B,IAAMA,EAAE,QAAQ,WAAY,MAAM,EAAI,IAEzC,SAAU,KAAKA,CAAC,EACb,IAAMA,EAAE,QAAQ,cAAe,MAAM,EAAI,IAE1C,OAAOA,CAAC,EAAE,QAAQ,+CAAgD,QAAQ,CAClF,CAAC,EAAE,KAAK,GAAG,CACZ,ICfA,IAAAC,EAAAC,EAAA,CAAAC,GAAAC,IAAA,cAIA,IAAIC,EAAU,MAAQ,CACrB,SACA,SACA,KACA,SACA,SACA,YACA,KACA,OACA,OACA,WACD,EAAE,KAAK,GAAG,EAAI,IACVC,EAAY,IAAI,OAAO,IAAMD,EAAU,GAAG,EAC1CE,EAAO,cACPC,GAAe,qBACfC,GAAe,qBACfC,GAAO,MAEPC,EAAK,IACLC,EAAK,IACLC,EAAK,IAELC,EAAQ,GACRC,GAAO,WACX,IAASC,EAAI,EAAGA,EAAI,EAAGA,IACtBF,IAAUC,GAAO,KAAK,OAAO,GAAG,SAAS,EAAE,EADnC,IAAAC,EAGLC,GAAkB,IAAI,OAAO,IAAMH,CAAK,EAE5C,SAASI,GAASC,EAAGC,EAAG,CAMvB,QALIC,EAAYD,EAAE,UAEdE,EAAU,CAAC,EACXC,EAEIA,EAAWH,EAAE,KAAKD,CAAC,GAC1BG,EAAQ,KAAKC,CAAQ,EACjBH,EAAE,YAAcG,EAAS,QAC5BH,EAAE,WAAa,GAIjB,OAAAA,EAAE,UAAYC,EAEPC,CACR,CAEA,SAASE,GAAOC,EAAKC,EAAKC,EAAK,CAC9B,IAAI,EAAI,OAAOF,GAAQ,WAAaA,EAAIE,CAAG,EAAIF,EAAIE,CAAG,EAOtD,OANI,OAAO,EAAM,KAAeA,GAAO,GACtC,EAAI,GACM,OAAO,EAAM,MACvB,EAAI,KAGD,OAAO,GAAM,SACTD,EAAMZ,EAAQ,KAAK,UAAU,CAAC,EAAIA,EAEnCY,EAAM,CACd,CAEA,SAASE,GAAcC,EAAQJ,EAAKK,EAAM,CACpCA,IACJA,EAAO,CAAC,GAET,IAAIC,EAAKD,EAAK,QAAU,KACpBE,EAAW,MAAQD,EAAK,MAASxB,EAAO,YAAeA,EAAO,MAE9D0B,EAAU,IAAI,OAAO,CACxB,IAAM5B,EAAU,IAChB,IAAM2B,EAAW,IAAMxB,GAAe,IAAMC,GAAe,IAC5D,EAAE,KAAK,GAAG,EAAG,GAAG,EAEZa,EAAUJ,GAASW,EAAQI,CAAO,EAEtC,GAAIX,EAAQ,SAAW,EACtB,MAAO,CAAC,EAEJG,IACJA,EAAM,CAAC,GAGR,IAAIS,EAAY,GAEhB,OAAOZ,EAAQ,IAAI,SAAUa,EAAO,CACnC,IAAIhB,EAAIgB,EAAM,CAAC,EACf,GAAI,CAAChB,GAAKe,EACT,OAED,GAAI5B,EAAU,KAAKa,CAAC,EACnB,MAAO,CAAE,GAAIA,CAAE,EAchB,IAAIiB,EAAQ,GACRC,EAAM,GACNC,EAAM,GACNC,EAAS,GACTvB,EAEJ,SAASwB,GAAc,CACtBxB,GAAK,EACL,IAAIyB,EACAC,EACAC,EAAOxB,EAAE,OAAOH,CAAC,EAErB,GAAI2B,IAAS,IAAK,CAEjB,GADA3B,GAAK,EACDG,EAAE,OAAOH,CAAC,IAAM,IACnB,MAAM,IAAI,MAAM,qBAAuBG,EAAE,MAAMH,EAAI,EAAGA,EAAI,CAAC,CAAC,EAG7D,GADAyB,EAAStB,EAAE,QAAQ,IAAKH,CAAC,EACrByB,EAAS,EACZ,MAAM,IAAI,MAAM,qBAAuBtB,EAAE,MAAMH,CAAC,CAAC,EAElD0B,EAAUvB,EAAE,MAAMH,EAAGyB,CAAM,EAC3BzB,EAAIyB,CACL,SAAY,aAAc,KAAKE,CAAI,EAClCD,EAAUC,EACV3B,GAAK,MACC,CACN,IAAI4B,EAAczB,EAAE,MAAMH,CAAC,EAC3ByB,EAASG,EAAY,MAAM,UAAU,EAChCH,GAIJC,EAAUE,EAAY,MAAM,EAAGH,EAAO,KAAK,EAC3CzB,GAAKyB,EAAO,MAAQ,IAJpBC,EAAUE,EACV5B,EAAIG,EAAE,OAKR,CACA,OAAOK,GAAOC,EAAK,GAAIiB,CAAO,CAC/B,CAEA,IAAK1B,EAAI,EAAGA,EAAIG,EAAE,OAAQH,IAAK,CAC9B,IAAI,EAAIG,EAAE,OAAOH,CAAC,EAElB,GADAuB,EAASA,GAAW,CAACH,IAAU,IAAM,KAAO,IAAM,KAC9CC,EACHC,GAAO,EACPD,EAAM,WACID,EACN,IAAMA,EACTA,EAAQ,GACEA,GAASzB,EACnB2B,GAAO,EAEH,IAAMP,GACTf,GAAK,EACL,EAAIG,EAAE,OAAOH,CAAC,EACV,IAAMJ,GAAM,IAAMmB,GAAM,IAAMlB,EACjCyB,GAAO,EAEPA,GAAOP,EAAK,GAEH,IAAMlB,EAChByB,GAAOE,EAAY,EAEnBF,GAAO,UAGC,IAAM1B,GAAM,IAAMD,EAC5ByB,EAAQ,MACF,IAAI9B,EAAU,KAAK,CAAC,EAC1B,MAAO,CAAE,GAAIa,CAAE,EACT,GAAIT,GAAK,KAAK,CAAC,EAAG,CACxBwB,EAAY,GACZ,IAAIW,EAAa,CAAE,QAAShB,EAAO,MAAMM,EAAM,MAAQnB,EAAI,CAAC,CAAE,EAC9D,OAAIsB,EAAI,OACA,CAACA,EAAKO,CAAU,EAEjB,CAACA,CAAU,CACnB,MAAW,IAAMd,EAChBM,EAAM,GACI,IAAMxB,EAChByB,GAAOE,EAAY,EAEnBF,GAAO,EAET,CAEA,OAAIC,EACI,CAAE,GAAI,OAAQ,QAASD,CAAI,EAG5BA,CACR,CAAC,EAAE,OAAO,SAAUQ,EAAMC,EAAK,CAE9B,OAAO,OAAOA,EAAQ,IAAcD,EAAOA,EAAK,OAAOC,CAAG,CAC3D,EAAG,CAAC,CAAC,CACN,CAEA3C,EAAO,QAAU,SAAee,EAAGM,EAAKK,EAAM,CAC7C,IAAIkB,EAASpB,GAAcT,EAAGM,EAAKK,CAAI,EACvC,OAAI,OAAOL,GAAQ,WACXuB,EAEDA,EAAO,OAAO,SAAUC,EAAK9B,EAAG,CACtC,GAAI,OAAOA,GAAM,SAChB,OAAO8B,EAAI,OAAO9B,CAAC,EAEpB,IAAI+B,EAAK/B,EAAE,MAAM,OAAO,IAAML,EAAQ,MAAQA,EAAQ,IAAK,GAAG,CAAC,EAC/D,OAAIoC,EAAG,SAAW,EACVD,EAAI,OAAOC,EAAG,CAAC,CAAC,EAEjBD,EAAI,OAAOC,EAAG,OAAO,OAAO,EAAE,IAAI,SAAUC,EAAG,CACrD,OAAIlC,GAAgB,KAAKkC,CAAC,EAClB,KAAK,MAAMA,EAAE,MAAMrC,CAAK,EAAE,CAAC,CAAC,EAE7BqC,CACR,CAAC,CAAC,CACH,EAAG,CAAC,CAAC,CACN,ICjOA,IAAAC,EAAAC,EAAAC,GAAA,cAEAA,EAAQ,MAAQ,IAChBA,EAAQ,MAAQ,MCAT,IAAMC,EAAN,KAAwB,CACtB,KACA,QACA,OAER,YAAYC,EAAc,CACzB,KAAK,KAAOA,EACZ,KAAK,QAAU,CAAC,EAChB,KAAK,OAAS,CACf,CAKA,KAAKC,EAAqB,CAEzB,GAAIA,EAAM,KAAK,IAAM,GAAI,OAGzB,IAAMC,EAAY,KAAK,QAAQ,KAAK,QAAQ,OAAS,CAAC,EAClDD,IAAUC,IAGd,KAAK,QAAQ,KAAKD,CAAK,EACnB,KAAK,QAAQ,OAAS,KAAK,MAC9B,KAAK,QAAQ,MAAM,EAEpB,KAAK,OAAS,KAAK,QAAQ,OAC5B,CAKA,QAAe,CACd,KAAK,OAAS,KAAK,QAAQ,MAC5B,CAKA,aAAkC,CACjC,IAAME,EAAM,KAAK,IAAI,EAAG,KAAK,OAAS,CAAC,EACvC,YAAK,OAASA,EACP,KAAK,QAAQA,CAAG,CACxB,CAKA,SAA8B,CAC7B,IAAMA,EAAM,KAAK,IAAI,KAAK,QAAQ,OAAQ,KAAK,OAAS,CAAC,EACzD,YAAK,OAASA,EACP,KAAK,QAAQA,CAAG,CACxB,CACD,ECzDA,IAAAC,EAAkC,QAK3B,SAASC,EACfC,EACAC,EAAoB,GACT,CACX,IAAIC,EACEC,EAAkB,CAAC,EACnBC,EAAa,OAEnB,KAAQF,EAAQE,EAAG,KAAKJ,CAAK,GAC5BG,EAAM,KAAKF,EAAWC,EAAM,MAAQA,EAAM,MAAQA,EAAM,CAAC,EAAE,MAAM,EAGlE,OAAOC,CACR,CAKO,SAASE,EAAoBL,EAAeM,EAAwB,CAI1E,OAHcP,EAAeC,EAAO,EAAI,EACtC,QAAQ,EACR,KAAMO,GAAMA,EAAID,CAAM,GACR,CACjB,CAKO,SAASE,EAAqBR,EAAeM,EAAwB,CAE3E,OADcP,EAAeC,EAAO,EAAK,EAAE,KAAMO,GAAMA,EAAID,CAAM,GACjDN,EAAM,MACvB,CAKO,SAASS,EACfT,EACAM,EACAI,EAC+B,CAC/B,IAAIC,EAAM,EACTC,EAAM,EAEP,QAASC,EAAI,EAAGA,EAAIP,EAAQ,EAAEO,EACjBb,EAAM,OAAOa,CAAC,IACd;AAAA,GACXD,EAAM,EACND,GAAO,IAEPC,GAAO,EACHA,EAAMF,IACTE,EAAM,EACND,GAAO,IAKV,MAAO,CAAE,IAAAA,EAAK,IAAAC,CAAI,CACnB,CAKO,SAASE,EAAWd,EAAeU,EAAyB,CAClE,OAAOD,EAAeT,EAAOA,EAAM,OAAQU,CAAO,EAAE,IAAM,CAC3D,CAKO,SAASK,EAAkBf,EAAwB,CACzD,OAAIA,EAAM,KAAK,IAAM,GACb,IAGHA,EAAM,MAAM,IAAI,GAAK,CAAC,GAAG,OAAS,IAAM,IAIxCA,EAAM,MAAM,IAAI,GAAK,CAAC,GAAG,OAAS,IAAM,GAK5CA,EACE,MAAM,eAAe,EACrB,IAAI,GACH,KAAK,IAAM,GAEP,GAGDA,EAAM,SAAS,IAAI,GAAK,CAACA,EAAM,SAAS,MAAM,CACtD,CAKO,SAASgB,EAAqBhB,EAAwB,CAC5D,MAAO,eAAe,KAAKA,CAAK,CACjC,CAKO,SAASiB,EAAajB,EAAuB,CACnD,OAAIA,EAAM,KAAK,IAAM,IAAMgB,EAAqBhB,CAAK,EAC7C,MAGO,SAAMA,CAAK,EACZ,IAAI,GAAK,EACxB,CAKO,SAASkB,EACfC,EAIAnB,EACW,CACX,IAAMoB,KAAS,SAAMpB,CAAK,EACtBqB,EAAQD,EAAO,OAAS,EACxBE,EAAOF,EAAOC,CAAK,GAAK,GAE5B,OAAIrB,EAAM,KAAK,IAAM,IACpBqB,EAAQ,EACRC,EAAO,IACGN,EAAqBhB,CAAK,IACpCqB,GAAS,EACTC,EAAO,IAGDH,EACL,OAAiB,CAACI,EAAY,CAAE,GAAAC,EAAI,KAAAC,CAAK,IAAM,CAC/C,GAAI,CACH,OAAOF,EAAW,OAAOC,EAAGH,EAAOD,EAAQ,GAAGK,CAAI,CAAC,CACpD,OAASC,EAAG,CACX,eAAQ,MAAM,uBAAwBA,CAAC,EAChCH,CACR,CACD,EAAG,CAAC,CAAC,EACJ,OAAQI,GAAQA,EAAI,WAAWL,CAAI,CAAC,CACvC,CAKO,SAASM,EACfC,EACAN,EACgB,CAChB,GAAIM,EAAS,QAAUN,EAAW,CAAC,EAAE,OAAQ,OAAOM,EAEpD,IAAMC,EAAcD,EACpBA,GAAYN,EAAW,CAAC,EAAE,MAAMM,EAAS,OAAQA,EAAS,OAAS,CAAC,EAEpE,QAAShB,EAAI,EAAGA,EAAIU,EAAW,OAAQV,IAAK,CAC3C,GAAI,CAACU,EAAWV,CAAC,EAAE,WAAWiB,CAAW,EAAG,OAAO,KACnD,GAAI,CAACP,EAAWV,CAAC,EAAE,WAAWgB,CAAQ,EACrC,OAAOC,CAET,CAEA,OAAOF,EAAkBC,EAAUN,CAAU,CAC9C,CCzHA,IAAqBQ,EAArB,KAAyC,CAChC,KACA,QACA,uBACA,sBACA,QACA,OACA,QACA,cACA,kBACA,UACA,aACA,gBACA,kBAER,YACCC,EAAwB,KACxBC,EAAsC,CAAC,EACtC,CACD,KAAK,KAAOD,EACZ,KAAK,gBAAkB,KAAK,eAAe,KAAK,IAAI,EACpD,KAAK,kBAAoB,KAAK,iBAAiB,KAAK,IAAI,EAExD,KAAK,QAAU,IAAIE,EAAkBD,EAAQ,aAAe,EAAE,EAC9D,KAAK,uBAAyBA,EAAQ,wBAA0B,IAEhE,KAAK,sBAAwB,CAAC,EAC9B,KAAK,QAAU,GACf,KAAK,OAAS,GACd,KAAK,QAAU,EACf,KAAK,cAAgB,KACrB,KAAK,kBAAoB,KACzB,KAAK,UAAY,CAChB,KAAM,EACN,KAAM,CACP,EAEA,KAAK,aAAe,CAAC,EAEjBD,IACC,cAAeA,EAAMA,EAAK,UAAU,IAAI,EACvC,KAAK,OAAO,EAEnB,CAGA,SAASA,EAAsB,CAC9B,KAAK,KAAOA,EACZ,KAAK,OAAO,CACb,CAEA,SAAgB,CACf,KAAK,OAAO,CACb,CASA,QAAe,CACV,KAAK,MAAQ,QAAS,KAAK,MAC9B,KAAK,KAAK,IAAI,OAAQ,KAAK,eAAe,EAC1C,KAAK,KAAK,IAAI,SAAU,KAAK,iBAAiB,IAE9C,KAAK,aAAa,QAASG,GAAMA,EAAE,QAAQ,CAAC,EAC5C,KAAK,aAAe,CAAC,EAEvB,CAKA,QAAe,CACV,KAAK,MAAQ,OAAQ,KAAK,MAC7B,KAAK,KAAK,GAAG,OAAQ,KAAK,eAAe,EACzC,KAAK,KAAK,GAAG,SAAU,KAAK,iBAAiB,GACnC,KAAK,OACf,KAAK,aAAa,KAAK,KAAK,KAAK,OAAO,KAAK,eAAe,CAAC,EAC7D,KAAK,aAAa,KAAK,KAAK,KAAK,SAAS,KAAK,iBAAiB,CAAC,GAElE,KAAK,UAAY,CAChB,KAAM,KAAK,KAAO,KAAK,KAAK,KAAO,EACnC,KAAM,KAAK,KAAO,KAAK,KAAK,KAAO,CACpC,CACD,CAKA,uBAAuBC,KAAiBC,EAAmB,CAC1D,KAAK,sBAAsB,KAAK,CAC/B,GAAAD,EACA,KAAAC,CACD,CAAC,CACF,CAKA,0BAA0BD,EAAoB,CAC7C,IAAME,EAAM,KAAK,sBAAsB,UAAWC,GAAMA,EAAE,KAAOH,CAAE,EAC/DE,IAAQ,IAEZ,KAAK,sBAAsB,OAAOA,EAAK,CAAC,CACzC,CAMA,KAAKE,EAAgBC,EAA6B,KAAuB,CACxE,OAAO,IAAI,QAAQ,CAACC,EAASC,IAAW,CACnC,KAAK,MAAM,KAAK,KAAK,MAAMH,CAAM,EACrC,KAAK,cAAgB,CACpB,OAAAA,EACA,mBAAAC,EACA,QAAAC,EACA,OAAAC,CACD,EAEA,KAAK,OAAS,GACd,KAAK,QAAU,EACf,KAAK,QAAU,EAChB,CAAC,CACF,CASA,SAASH,EAAiC,CACzC,OAAO,IAAI,QAAQ,CAACE,EAASC,IAAW,CACnC,KAAK,MAAM,KAAK,KAAK,MAAMH,CAAM,EACrC,KAAK,kBAAoB,CACxB,OAAAA,EACA,QAAAE,EACA,OAAAC,CACD,CACD,CAAC,CACF,CAKA,UAAUC,EAAiB,UAAiB,EACvC,KAAK,eAAiB,MAAQ,KAAK,mBAAqB,OACvD,KAAK,MAAM,KAAK,KAAK,MAAM;AAAA,CAAM,EAElC,KAAK,eAAiB,OACzB,KAAK,cAAc,OAAOA,CAAM,EAChC,KAAK,cAAgB,MAElB,KAAK,mBAAqB,OAC7B,KAAK,kBAAkB,OAAOA,CAAM,EACpC,KAAK,kBAAoB,MAE1B,KAAK,QAAU,EAChB,CAKA,QAAQC,EAAuB,CAC9B,KAAK,MAAMA,EAAU;AAAA,CAAI,CAC1B,CAKA,MAAMA,EAAuB,CAC5B,IAAMC,EAAYD,EAAQ,QAAQ,WAAY;AAAA,CAAI,EAC9C,KAAK,MAAM,KAAK,KAAK,MAAMC,EAAU,QAAQ,MAAO;AAAA,CAAM,CAAC,CAChE,CAKA,UAAUC,EAAiBC,EAAkB,EAAS,CACrD,GAAID,EAAM,QAAU,EAAG,OAAO,KAAK,QAAQ,EAAE,EAG7C,IAAME,EACLF,EAAM,OAAO,CAACG,EAAOC,IAAS,KAAK,IAAID,EAAOC,EAAK,MAAM,EAAG,CAAC,EAC7DH,EACKI,EAAW,KAAK,MAAM,KAAK,UAAU,KAAOH,CAAS,EACrDI,EAAW,KAAK,KAAKN,EAAM,OAASK,CAAQ,EAG9CE,EAAI,EACR,QAASC,EAAM,EAAGA,EAAMF,EAAU,EAAEE,EAAK,CACxC,IAAIC,EAAS,GAGb,QAASC,EAAM,EAAGA,EAAML,EAAU,EAAEK,EACnC,GAAIH,EAAIP,EAAM,OAAQ,CACrB,IAAII,EAAOJ,EAAMO,GAAG,EACpBH,GAAQ,IAAI,OAAOF,EAAYE,EAAK,MAAM,EAC1CK,GAAUL,CACX,CAED,KAAK,QAAQK,CAAM,CACpB,CACD,CASQ,aAAaE,EAAuB,CAC3C,IAAMlB,GAAU,KAAK,eAAiB,CAAC,GAAG,QAAU,GAC9CC,GACJ,KAAK,eAAiB,CAAC,GAAG,oBAAsB,GAElD,OAAOD,EAASkB,EAAM,QAAQ,MAAO;AAAA,EAAOjB,CAAkB,CAC/D,CAMQ,kBAAkBiB,EAAeC,EAAwB,CAEhE,OADiB,KAAK,aAAaD,EAAM,OAAO,EAAGC,CAAM,CAAC,EAC1C,MACjB,CAQQ,YAAmB,CAC1B,IAAMC,EAAgB,KAAK,aAAa,KAAK,MAAM,EAG7CC,EAAUC,EAAWF,EAAe,KAAK,UAAU,IAAI,EAGvDG,EAAe,KAAK,kBAAkB,KAAK,OAAQ,KAAK,OAAO,EAC/D,CAAE,IAAAN,EAAK,IAAAF,CAAI,EAAIS,EACpBJ,EACAG,EACA,KAAK,UAAU,IAChB,EAGME,EAAWJ,EAAUN,EAAM,EACjC,QAASD,EAAI,EAAGA,EAAIW,EAAU,EAAEX,EAC3B,KAAK,MAAM,KAAK,KAAK,MAAM,QAAQ,EAIxC,GAAI,KAAK,KAAM,CACd,KAAK,KAAK,MAAM,UAAU,EAC1B,QAASA,EAAI,EAAGA,EAAIO,EAAS,EAAEP,EAAG,KAAK,KAAK,MAAM,cAAc,CACjE,CACD,CAQQ,SAASY,EAAkBC,EAAsB,GAAY,CAEhEA,GAAY,KAAK,WAAW,EAGhC,IAAMC,EAAY,KAAK,aAAaF,CAAQ,EAC5C,KAAK,MAAME,CAAS,EAGhB,KAAK,QAAUF,EAAS,SAC3B,KAAK,QAAUA,EAAS,QAIzB,IAAMG,EAAY,KAAK,kBAAkBH,EAAU,KAAK,OAAO,EACzDI,EAAWR,EAAWM,EAAW,KAAK,UAAU,IAAI,EACpD,CAAE,IAAAX,EAAK,IAAAF,CAAI,EAAIS,EACpBI,EACAC,EACA,KAAK,UAAU,IAChB,EACME,EAAaD,EAAWf,EAAM,EAEpC,GAAI,KAAK,KAAM,CACd,KAAK,KAAK,MAAM,IAAI,EACpB,QAASD,EAAI,EAAGA,EAAIiB,EAAY,EAAEjB,EAAG,KAAK,KAAK,MAAM,QAAQ,EAC7D,QAASA,EAAI,EAAGA,EAAIG,EAAK,EAAEH,EAAG,KAAK,KAAK,MAAM,QAAQ,CACvD,CAGA,KAAK,OAASY,CACf,CAMQ,sBAAsBM,EAA4C,CACzE,IAAMC,EAAS,KAAK,QAGpB,KAAK,UAAU,KAAK,OAAO,MAAM,EAC7B,KAAK,MAAM,KAAK,KAAK,MAAM;AAAA,CAAM,EAGrC,IAAMC,EAAS,IAAM,CACpB,KAAK,QAAUD,EACf,KAAK,SAAS,KAAK,MAAM,CAC1B,EAIME,EAAMH,EAAS,EACjBG,GAAO,KACVD,EAAO,EAEPC,EAAI,KAAKD,CAAM,CAEjB,CAQQ,UAAUL,EAAyB,CACtCA,EAAY,IAAGA,EAAY,GAC3BA,EAAY,KAAK,OAAO,SAAQA,EAAY,KAAK,OAAO,QAG5D,IAAMO,EAAkB,KAAK,aAAa,KAAK,MAAM,EAC/CC,EAAaf,EAAWc,EAAiB,KAAK,UAAU,IAAI,EAG5DE,EAAmB,KAAK,kBAC7B,KAAK,OACL,KAAK,OACN,EACM,CAAE,IAAKC,EAAS,IAAKC,CAAQ,EAAIhB,EACtCY,EACAE,EACA,KAAK,UAAU,IAChB,EAGMG,EAAkB,KAAK,kBAAkB,KAAK,OAAQZ,CAAS,EAC/D,CAAE,IAAKa,EAAQ,IAAKC,CAAO,EAAInB,EACpCY,EACAK,EACA,KAAK,UAAU,IAChB,EAGA,GAAI,KAAK,KAAM,CACd,GAAIE,EAASH,EACZ,QAAS1B,EAAI0B,EAAS1B,EAAI6B,EAAQ,EAAE7B,EACnC,KAAK,KAAK,MAAM,QAAQ,MAEzB,SAASA,EAAI6B,EAAQ7B,EAAI0B,EAAS,EAAE1B,EACnC,KAAK,KAAK,MAAM,QAAQ,EAI1B,GAAI4B,EAASH,EACZ,QAASzB,EAAIyB,EAASzB,EAAI4B,EAAQ,EAAE5B,EACnC,KAAK,KAAK,MAAM,QAAQ,MAEzB,SAASA,EAAI4B,EAAQ5B,EAAIyB,EAAS,EAAEzB,EACnC,KAAK,KAAK,MAAM,QAAQ,CAE3B,CAGA,KAAK,QAAUe,CAChB,CAKQ,iBAAiBe,EAAmB,CAC3C,GAAIA,EAAM,EAAG,CACZ,IAAMC,EAAM,KAAK,IAAID,EAAK,KAAK,OAAO,OAAS,KAAK,OAAO,EAC3D,KAAK,UAAU,KAAK,QAAUC,CAAG,CAClC,SAAWD,EAAM,EAAG,CACnB,IAAMC,EAAM,KAAK,IAAID,EAAK,CAAC,KAAK,OAAO,EACvC,KAAK,UAAU,KAAK,QAAUC,CAAG,CAClC,CACD,CAKQ,kBAAkBC,EAA0B,CACnD,GAAM,CAAE,QAAAC,EAAS,OAAAC,CAAO,EAAI,KAC5B,GAAIF,EAAW,CACd,GAAIC,GAAW,EAAG,OAClB,IAAMrB,EACLsB,EAAO,OAAO,EAAGD,EAAU,CAAC,EAAIC,EAAO,OAAOD,CAAO,EACtD,KAAK,WAAW,EAChB,KAAK,SAAW,EAChB,KAAK,SAASrB,EAAU,EAAK,CAC9B,KAAO,CACN,IAAMA,EACLsB,EAAO,OAAO,EAAGD,CAAO,EAAIC,EAAO,OAAOD,EAAU,CAAC,EACtD,KAAK,SAASrB,CAAQ,CACvB,CACD,CAKQ,mBAAmBuB,EAAoB,CAC9C,GAAM,CAAE,QAAAF,EAAS,OAAAC,CAAO,EAAI,KACtBtB,EACLsB,EAAO,OAAO,EAAGD,CAAO,EAAIE,EAAOD,EAAO,OAAOD,CAAO,EACzD,KAAK,SAAWE,EAAK,OACrB,KAAK,SAASvB,CAAQ,CACvB,CAKQ,oBAA2B,CAC9B,KAAK,SACR,KAAK,QAAQ,KAAK,KAAK,MAAM,EAE1B,KAAK,gBACR,KAAK,cAAc,QAAQ,KAAK,MAAM,EACtC,KAAK,cAAgB,MAElB,KAAK,MAAM,KAAK,KAAK,MAAM;AAAA,CAAM,EACrC,KAAK,QAAU,EAChB,CASQ,iBAAiBuB,EAA4C,CACpE,GAAM,CAAE,KAAAC,EAAM,KAAAC,CAAK,EAAIF,EACvB,KAAK,WAAW,EAChB,KAAK,UAAY,CAAE,KAAAE,EAAM,KAAAD,CAAK,EAC9B,KAAK,SAAS,KAAK,OAAQ,EAAK,CACjC,CAKQ,eAAeD,EAAoB,CAC1C,GAAK,KAAK,QAGV,IAAI,KAAK,mBAAqB,KAAM,CACnC,KAAK,kBAAkB,QAAQA,CAAI,EACnC,KAAK,kBAAoB,KACrB,KAAK,MAAM,KAAK,KAAK,MAAM;AAAA,CAAM,EACrC,MACD,CAGA,GAAIA,EAAK,OAAS,GAAKA,EAAK,WAAW,CAAC,IAAM,GAAM,CACnD,IAAMG,EAAWH,EAAK,QAAQ,WAAY,IAAI,EAC9C,MAAM,KAAKG,CAAQ,EAAE,QAASC,GAAM,KAAK,WAAWA,CAAC,CAAC,CACvD,MACC,KAAK,WAAWJ,CAAI,EAEtB,CAKQ,WAAWA,EAAoB,CACtC,GAAI,CAAC,KAAK,QAAS,OACnB,IAAMK,EAAML,EAAK,WAAW,CAAC,EACzBM,EAGJ,GAAID,GAAO,GACV,OAAQL,EAAK,OAAO,CAAC,EAAG,CACvB,IAAK,KACJ,GAAI,KAAK,QAAS,CACjB,IAAIO,EAAQ,KAAK,QAAQ,YAAY,EACjCA,IACH,KAAK,SAASA,CAAK,EACnB,KAAK,UAAUA,EAAM,MAAM,EAE7B,CACA,MAED,IAAK,KACJ,GAAI,KAAK,QAAS,CACjB,IAAIA,EAAQ,KAAK,QAAQ,QAAQ,EAC5BA,IAAOA,EAAQ,IACpB,KAAK,SAASA,CAAK,EACnB,KAAK,UAAUA,EAAM,MAAM,CAC5B,CACA,MAED,IAAK,KACJ,KAAK,iBAAiB,EAAE,EACxB,MAED,IAAK,KACJ,KAAK,iBAAiB,CAAC,EACvB,MAED,IAAK,MACJ,KAAK,kBAAkB,EAAK,EAC5B,MAED,IAAK,KACJ,KAAK,UAAU,KAAK,OAAO,MAAM,EACjC,MAED,IAAK,KACJ,KAAK,UAAU,CAAC,EAChB,MAED,IAAK,IACJD,EAAME,EAAoB,KAAK,OAAQ,KAAK,OAAO,EAC/CF,GAAO,MAAM,KAAK,UAAUA,CAAG,EACnC,MAED,IAAK,IACJA,EAAMG,EAAqB,KAAK,OAAQ,KAAK,OAAO,EAChDH,GAAO,MAAM,KAAK,UAAUA,CAAG,EACnC,MAED,IAAK,OACJA,EAAME,EAAoB,KAAK,OAAQ,KAAK,OAAO,EAC/CF,GAAO,OACV,KAAK,SACJ,KAAK,OAAO,OAAO,EAAGA,CAAG,EACxB,KAAK,OAAO,OAAO,KAAK,OAAO,CACjC,EACA,KAAK,UAAUA,CAAG,GAEnB,KACF,SAGUD,EAAM,IAAMA,IAAQ,IAC9B,OAAQL,EAAM,CACb,IAAK,KACAU,EAAkB,KAAK,MAAM,EAChC,KAAK,mBAAmB;AAAA,CAAI,EAE5B,KAAK,mBAAmB,EAEzB,MAED,IAAK,OACJ,KAAK,kBAAkB,EAAI,EAC3B,MAED,IAAK,IACJ,GAAI,KAAK,sBAAsB,OAAS,EAAG,CAC1C,IAAMC,EAAgB,KAAK,OAAO,OACjC,EACA,KAAK,OACN,EACMC,EACLC,EAAqBF,CAAa,EAC7BG,EAAaC,EAClB,KAAK,sBACLJ,CACD,EAOA,GAJAG,EAAW,KAAK,EAIZA,EAAW,SAAW,EAEpBF,GACJ,KAAK,mBAAmB,GAAG,UAElBE,EAAW,SAAW,EAAG,CAEnC,IAAME,EAAYC,EAAaN,CAAa,EAC5C,KAAK,mBACJG,EAAW,CAAC,EAAE,OAAOE,EAAU,MAAM,EAAI,GAC1C,CACD,SACCF,EAAW,QAAU,KAAK,uBACzB,CAED,IAAMI,EAAiBC,EACtBR,EACAG,CACD,EAIA,GAAII,EAAgB,CACnB,IAAMF,EAAYC,EAAaN,CAAa,EAC5C,KAAK,mBACJO,EAAe,OAAOF,EAAU,MAAM,CACvC,CACD,CAIA,KAAK,sBAAsB,IAAM,CAChC,KAAK,UAAUF,CAAU,CAC1B,CAAC,CACF,MAGC,KAAK,sBAAsB,IAC1B,KAAK,SACJ,eAAeA,EAAW,MAAM,0BACjC,EAAE,KAAMM,GAAO,EACVA,GAAM,KAAOA,GAAM,MACtB,KAAK,UAAUN,CAAU,CAE3B,CAAC,CACF,CAEF,MACC,KAAK,mBAAmB,MAAM,EAE/B,MAED,IAAK,IACJ,KAAK,UAAU,KAAK,OAAO,MAAM,EAC7B,KAAK,MACR,KAAK,KAAK,MACT;AAAA,IACG,KAAK,eAAiB,CAAC,GAAG,QAAU,GACxC,EACD,KAAK,OAAS,GACd,KAAK,QAAU,EACX,KAAK,SAAS,KAAK,QAAQ,OAAO,EACtC,KACF,MAIA,KAAK,mBAAmBd,CAAI,CAE9B,CACD,ECtsBA,IAAOqB,GAAQC",
  "names": ["require_quote", "__commonJSMin", "exports", "module", "xs", "s", "require_parse", "__commonJSMin", "exports", "module", "CONTROL", "controlRE", "META", "SINGLE_QUOTE", "DOUBLE_QUOTE", "hash", "SQ", "DQ", "DS", "TOKEN", "mult", "i", "startsWithToken", "matchAll", "s", "r", "origIndex", "matches", "matchObj", "getVar", "env", "pre", "key", "parseInternal", "string", "opts", "BS", "BAREWORD", "chunker", "commented", "match", "quote", "esc", "out", "isGlob", "parseEnvVar", "varend", "varname", "char", "slicedFromI", "commentObj", "prev", "arg", "mapped", "acc", "xs", "x", "require_shell_quote", "__commonJSMin", "exports", "HistoryController", "size", "entry", "lastEntry", "idx", "import_shell_quote", "wordBoundaries", "input", "leftSide", "match", "words", "rx", "closestLeftBoundary", "offset", "x", "closestRightBoundary", "offsetToColRow", "maxCols", "row", "col", "i", "countLines", "isIncompleteInput", "hasTailingWhitespace", "getLastToken", "collectAutocompleteCandidates", "callbacks", "tokens", "index", "expr", "candidates", "fn", "args", "e", "txt", "getSharedFragment", "fragment", "oldFragment", "LocalEchoController", "term", "options", "HistoryController", "d", "fn", "args", "idx", "e", "prompt", "continuationPrompt", "resolve", "reject", "reason", "message", "normInput", "items", "padding", "itemWidth", "width", "item", "wideCols", "wideRows", "i", "row", "rowStr", "col", "input", "offset", "currentPrompt", "allRows", "countLines", "promptCursor", "offsetToColRow", "moveRows", "newInput", "clearInput", "newPrompt", "newCursor", "newLines", "moveUpRows", "callback", "cursor", "resume", "ret", "inputWithPrompt", "inputLines", "prevPromptOffset", "prevCol", "prevRow", "newPromptOffset", "newCol", "newRow", "dir", "num", "backspace", "_cursor", "_input", "data", "rows", "cols", "normData", "c", "ord", "ofs", "value", "closestLeftBoundary", "closestRightBoundary", "isIncompleteInput", "inputFragment", "hasTailingSpace", "hasTailingWhitespace", "candidates", "collectAutocompleteCandidates", "lastToken", "getLastToken", "sharedFragment", "getSharedFragment", "yn", "local_echo_default", "LocalEchoController"]
}
